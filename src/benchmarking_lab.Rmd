---
title: "Benchmarking Lab"
output: github_document
---

```{r setup}
# Set working directory
# knitr::opts_knit$set(root.dir = "/home/esa/production_forecasts") # Working on Ubuntu
knitr::opts_knit$set(root.dir = "V:/production_forecasts") # Working home
```

## Create original dataset that should remain immutable throughout labbing
```{r message=FALSE}
library(forecast)
library(ggplot2)
library(gridExtra)
library(knitr)
source("src/evalhelp.R")

# Load data
monthly_sales <- read.table("./data/kuukausimyynti.txt", header = T, sep = "\t")

# Separate yyyy/mmm column into months and years
monthly_sales$year <- substr(monthly_sales$kuukausi, 1, 4)
monthly_sales$month <- factor(substr(monthly_sales$kuukausi, 6, 8), levels = c("tam", "hel", "maa", "huh", "tou", "kes", "hei", "elo", "syy", "lok", "mar", "jou"))

# Create a numeric column for months
monthly_sales$month_num <- as.numeric(monthly_sales$month)

# Omit empty values
d <- na.omit(monthly_sales)
```

## Create the time series object
```{r}
ts.red <- ts(d$Punasoluvalmisteet, 
             start = as.numeric(c(d$year[1], d$month_num[1])), 
             end = as.numeric(c(tail(d$year, 1), tail(d$month_num, 1))), 
             frequency = 12)  # This tells the series that it is monthly data

# Business day adjustment
ts.red.adj <- ts.red/bizdays(ts.red, FinCenter = "Zurich")  # Zurich is closest to Finnish business calendar, implementing of which would be a chore
```


## Get baseline benchmarks to beat
```{r}
# Random walk with drift
rwf.e <- tsCV(ts.red, rwf, drift = TRUE, h = 1)
rwf.crit <- cMAPE(rwf.e, ts.red)
rwf.rmse <- sqrt(mean(rwf.e^2, na.rm = TRUE))
rwf.mape <- mean(abs(100*rwf.e/ts.red), na.rm = TRUE)

# Naive
naive.e <- tsCV(ts.red, naive, h = 1)
naive.crit <- cMAPE(naive.e, ts.red)
naive.rmse <- sqrt(mean(naive.e^2, na.rm = TRUE))
naive.mape <- mean(abs(100*naive.e/ts.red), na.rm = TRUE)

# Seasonal naive
snaive.e <- tsCV(ts.red, snaive, h = 1)
snaive.crit <- cMAPE(snaive.e, ts.red)
snaive.rmse <- sqrt(mean(snaive.e^2, na.rm = TRUE))
snaive.mape <- mean(abs(100*snaive.e/ts.red), na.rm = TRUE)

# Mean forecast
meanf.e <- tsCV(ts.red, meanf, h = 1)
meanf.crit <- cMAPE(meanf.e, ts.red)
meanf.rmse <- sqrt(mean(meanf.e^2, na.rm = TRUE))
meanf.mape <- mean(abs(100*meanf.e/ts.red), na.rm = TRUE)

benchmarks <- matrix(c(rwf.crit, rwf.mape, rwf.rmse,
                       naive.crit, naive.mape, naive.rmse,
                       snaive.crit, snaive.mape, snaive.rmse,
                       meanf.crit, meanf.mape, meanf.rmse),
                     ncol = 3,
                     byrow = TRUE)
colnames(benchmarks) <- c("cMAPE", "MAPE", "RMSE")
rownames(benchmarks) <- c("RWF", "NAIVE", "SNAIVE", "MEANF")
kable(benchmarks, "markdown")
```

## Benchmarks with business day adjustment

```{r}
# Random walk with drift
rwf.e.adj <- tsCV(ts.red.adj, rwf, drift = TRUE, h = 1)
rwf.crit.adj <- cMAPE(rwf.e.adj, ts.red.adj)
rwf.rmse.adj <- sqrt(mean(rwf.e.adj^2, na.rm = TRUE))
rwf.mape.adj <- mean(abs(100*rwf.e.adj/ts.red.adj), na.rm = TRUE)

# Naive
naive.e.adj <- tsCV(ts.red.adj, naive, h = 1)
naive.crit.adj <- cMAPE(naive.e.adj, ts.red.adj)
naive.rmse.adj <- sqrt(mean(naive.e.adj^2, na.rm = TRUE))
naive.mape.adj <- mean(abs(100*naive.e.adj/ts.red.adj), na.rm = TRUE)

# Seasonal naive
snaive.e.adj <- tsCV(ts.red.adj, snaive, h = 1)
snaive.crit.adj <- cMAPE(snaive.e.adj, ts.red.adj)
snaive.rmse.adj <- sqrt(mean(snaive.e.adj^2, na.rm = TRUE))
snaive.mape.adj <- mean(abs(100*snaive.e.adj/ts.red.adj), na.rm = TRUE)

# Mean forecast
meanf.e.adj <- tsCV(ts.red.adj, meanf, h = 1)
meanf.crit.adj <- cMAPE(meanf.e.adj, ts.red.adj)
meanf.rmse.adj <- sqrt(mean(meanf.e.adj^2, na.rm = TRUE))
meanf.mape.adj <- mean(abs(100*meanf.e.adj/ts.red.adj), na.rm = TRUE)

benchmarks.adj <- matrix(c(rwf.crit.adj, rwf.mape.adj, rwf.rmse.adj,
                       naive.crit.adj, naive.mape.adj, naive.rmse.adj,
                       snaive.crit.adj, snaive.mape.adj, snaive.rmse.adj,
                       meanf.crit.adj, meanf.mape.adj, meanf.rmse.adj),
                     ncol = 3,
                     byrow = TRUE)
colnames(benchmarks.adj) <- c("cMAPE_adj", "MAPE_adj", "RMSE_adj")
rownames(benchmarks.adj) <- c("RWF", "NAIVE", "SNAIVE", "MEANF")
kable(benchmarks.adj, "markdown")
```


## Moving average benchmark
Using adjusted values
```{r}
# 5-MA
ma5.e.adj <- tsCV(ts.red.adj, fMA, order = 5, h = 1)
ma5.crit.adj <- cMAPE(ma5.e.adj, ts.red.adj)
ma5.rmse.adj <- sqrt(mean(ma5.e.adj^2, na.rm = TRUE))
ma5.mape.adj <- mean(abs(100*ma5.e.adj/ts.red.adj), na.rm = TRUE)

# 7-MA
ma7.e.adj <- tsCV(ts.red.adj, fMA, order = 7, h = 1)
ma7.crit.adj <- cMAPE(ma7.e.adj, ts.red.adj)
ma7.rmse.adj <- sqrt(mean(ma7.e.adj^2, na.rm = TRUE))
ma7.mape.adj <- mean(abs(100*ma7.e.adj/ts.red.adj), na.rm = TRUE)

mabench <- matrix(c(ma7.crit.adj, ma7.mape.adj, ma7.rmse.adj,
                    ma5.crit.adj, ma5.mape.adj, ma5.rmse.adj),
                   ncol = 3,
                   byrow = TRUE)

colnames(mabench) <- c("cMAPE", "MAPE", "RMSE")
rownames(mabench) <- c("7-MA ADJ", "5-MA ADJ")
kable(mabench, "markdown")
```

## Jarno's forecasts
```{r}
jstl.e <- tsCV(ts.red, fstl, t.window = 6, h = 1)
jstl.crit <- cMAPE(jstl.e, ts.red)
jstl.mape <- mean(abs(100*jstl.e/ts.red), na.rm = TRUE)
jstl.rmse <- sqrt(mean(jstl.e^2, na.rm = TRUE))

jstl.e.adj <- tsCV(ts.red.adj, fstl, t.window = 6, h = 1)
jstl.crit.adj <- cMAPE(jstl.e.adj, ts.red.adj)
jstl.mape.adj <- mean(abs(100*jstl.e.adj/ts.red.adj), na.rm = TRUE)
jstl.rmse.adj <- sqrt(mean(jstl.e.adj^2, na.rm = TRUE))

jets.e <- tsCV(ts.red, fets, h = 1)
jets.crit <- cMAPE(jets.e, ts.red)
jets.mape <- mean(abs(100*jets.e/ts.red), na.rm = TRUE)
jets.rmse <- sqrt(mean(jets.e^2, na.rm = TRUE))

jets.e.adj <- tsCV(ts.red.adj, fets, t.window = 6, h = 1)
jets.crit.adj <- cMAPE(jets.e.adj, ts.red.adj)
jets.mape.adj <- mean(abs(100*jets.e.adj/ts.red.adj), na.rm = TRUE)
jets.rmse.adj <- sqrt(mean(jets.e.adj^2, na.rm = TRUE))

oldbench <- matrix(c(jstl.crit, jstl.mape, jstl.rmse, 
                     jets.crit, jets.mape, jets.rmse,
                     jstl.crit.adj, jstl.mape.adj, jstl.rmse.adj,
                     jets.crit.adj, jets.mape.adj, jets.rmse.adj),
                   ncol = 3,
                   byrow = TRUE)
colnames(oldbench) <- c("cMAPE", "MAPE", "RMSE")
rownames(oldbench) <- c("STL", "ETS", "STL ADJ", "ETS ADJ")
kable(oldbench, "markdown")
```

Adjusted values are consistently better, so we'll use adjusted from now on.

## Complex decompositions
```{r}
stlf.e.adj <- tsCV(ts.red.adj, stlf, h = 1)
stlf.crit.adj <- cMAPE(stlf.e.adj, ts.red.adj)
stlf.mape.adj <- mean(abs(100*stlf.e.adj/ts.red.adj), na.rm = TRUE)
stlf.rmse.adj <- sqrt(mean(stlf.e.adj^2, na.rm = TRUE))

tbats.e.adj <- tsCV(ts.red.adj, fTBATS, h = 1)
tbats.crit.adj <- cMAPE(tbats.e.adj, ts.red.adj)
tbats.mape.adj <- mean(abs(100*tbats.e.adj/ts.red.adj), na.rm = TRUE)
tbats.rmse.adj <- sqrt(mean(tbats.e.adj^2, na.rm = TRUE))

complex <- matrix(c(stlf.crit.adj, stlf.mape.adj, stlf.rmse.adj,
                    tbats.crit.adj, tbats.mape.adj, tbats.rmse.adj),
                  ncol = 3,
                  byrow = TRUE)
colnames(complex) <- c("cMAPE", "MAPE", "RMSE")
rownames(complex) <- c("STLF (adj)", "TBATS (adj)")
kable(complex, "markdown")
```


## Shorter series
We'll use an MSTL+ETS model and monthly adjusted values, as those have been the best performing ones
```{r}
# 5 year rolling window
stlf5.e.adj <- tsCV(ts.red.adj, stlf, window = 60, h = 1)
stlf5.crit.adj <- cMAPE(stlf5.e.adj, ts.red.adj)
stlf5.mape.adj <- mean(abs(100*stlf5.e.adj/ts.red.adj), na.rm = TRUE)
stlf5.rmse.adj <- sqrt(mean(stlf5.e.adj^2, na.rm = TRUE))

# 4 year rolling window
stlf4.e.adj <- tsCV(ts.red.adj, stlf, window = 48, h = 1)
stlf4.crit.adj <- cMAPE(stlf4.e.adj, ts.red.adj)
stlf4.mape.adj <- mean(abs(100*stlf4.e.adj/ts.red.adj), na.rm = TRUE)
stlf4.rmse.adj <- sqrt(mean(stlf4.e.adj^2, na.rm = TRUE))

# 3 year rolling window (smallest possible for stl)
stlf3.e.adj <- tsCV(ts.red.adj, stlf, window = 36, h = 1)
stlf3.crit.adj <- cMAPE(stlf3.e.adj, ts.red.adj)
stlf3.mape.adj <- mean(abs(100*stlf3.e.adj/ts.red.adj), na.rm = TRUE)
stlf3.rmse.adj <- sqrt(mean(stlf3.e.adj^2, na.rm = TRUE))

# From 2012 onwards
stlf2012.e.adj <- tsCV(tail(ts.red.adj, 72), stlf, h = 1)
stlf2012.crit.adj <- cMAPE(stlf2012.e.adj, tail(ts.red.adj, 84))
stlf2012.mape.adj <- mean(abs(100*stlf2012.e.adj/tail(ts.red.adj, 84)), na.rm = TRUE)
stlf2012.rmse.adj <- sqrt(mean(stlf2012.e.adj^2, na.rm = TRUE))

rolling <- matrix(c(stlf5.crit.adj, stlf5.mape.adj, stlf5.rmse.adj,
                    stlf4.crit.adj, stlf4.mape.adj, stlf4.rmse.adj,
                    stlf3.crit.adj, stlf3.mape.adj, stlf3.rmse.adj,
                    stlf2012.crit.adj, stlf2012.mape.adj, stlf2012.rmse.adj),
                  ncol = 3,
                  byrow = TRUE)
colnames(rolling) <- c("cMAPE", "MAPE", "RMSE")
rownames(rolling) <- c("STLF 5", "STLF 4", "STLF 3", "STLF 2012")
kable(rolling, "markdown")
```

# Smoothed tests
This will have to be done "the old way", because tSCV() cannot be given two different series for error calculation.
**THIS WILL MAKE THE RESULTS INCOMPARABLE**
```{r}
# Filter
smooth25.red.adj <- ts(itsmr::smooth.fft(ts.red.adj, .25), start = as.numeric(c(d$year[1], d$month_num[1])), 
                   end = as.numeric(c(tail(d$year, 1), tail(d$month_num, 1))), frequency = 12)
smooth10.red.adj <- ts(itsmr::smooth.fft(ts.red.adj, .1), start = as.numeric(c(d$year[1], d$month_num[1])),
                   end = as.numeric(c(tail(d$year, 1), tail(d$month_num, 1))), frequency = 12)

stl_smooth_plot <- ggplot() 
stl_smooth_cMAPE <- c()
stl_smooth_RMSE <- c()
stl_smooth_MAPE <- c()
# Loop 
for(i in seq(from = 48, to = 180, by = 1)){
  fit <- stl(head(smooth25.red.adj, i), s.window = "periodic", t.window = 7)  # Fit based on history so far
  fcast <- forecast(fit, h = 1)  # Forecast the next month
  segment <- ts.red.adj[i + 1]  # Extract that year from the history for errror
  
  # Build the plot piece by piece
  stl_smooth_plot <- stl_smooth_plot + autolayer(fcast)
  
  # Calculate raw forecast errors
  pe <- 100*(data.frame(fcast)$Point.Forecast - segment)/segment
  crt <- mean(ifelse(test = pe < 0, yes = abs(pe * 2), no = pe), na.rm = TRUE)
  stl_smooth_cMAPE <- c(stl_smooth_cMAPE, crt) 
  
  stl_smooth_RMSE <- c(stl_smooth_RMSE, data.frame(accuracy(fcast, segment))$RMSE)
  stl_smooth_MAPE <- c(stl_smooth_MAPE, data.frame(accuracy(fcast, segment))$MAPE)
}

stl_smooth_plot + ggtitle("STL forecast of adjusted smoothed (.25) red cell sales month by month") +
  scale_x_discrete(limits=c(2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018)) + xlab("Time") +
  ylab("Unit sales") + autolayer(window(ts.red.adj, start = 2008), colour = FALSE) +
  geom_text(aes(2018, 1000, label = paste("RMSE: ", as.name(mean(stl_smooth_RMSE))))) + 
  geom_text(aes(2018, 1050, label = paste("MAPE: ", as.name(mean(stl_smooth_MAPE))))) +
  geom_text(aes(2018, 1100, label = paste("cMAPE: ", as.name(mean(stl_smooth_cMAPE)))))
```
```{r}
stl_smooth_plot <- ggplot() 
stl_smooth_cMAPE <- c()
stl_smooth_RMSE <- c()
stl_smooth_MAPE <- c()
# Loop 
for(i in seq(from = 48, to = 180, by = 1)){
  fit <- stl(head(smooth10.red.adj, i), s.window = "periodic", t.window = 7)  # Fit based on history so far
  fcast <- forecast(fit, h = 1)  # Forecast the next month
  segment <- ts.red.adj[i + 1]  # Extract that year from the history for errror
  
  # Build the plot piece by piece
  stl_smooth_plot <- stl_smooth_plot + autolayer(fcast)
  
  # Calculate raw forecast errors
  pe <- 100*(data.frame(fcast)$Point.Forecast - segment)/segment
  crt <- mean(ifelse(test = pe < 0, yes = abs(pe * 2), no = pe), na.rm = TRUE)
  stl_smooth_cMAPE <- c(stl_smooth_cMAPE, crt) 
  
  stl_smooth_RMSE <- c(stl_smooth_RMSE, data.frame(accuracy(fcast, segment))$RMSE)
  stl_smooth_MAPE <- c(stl_smooth_MAPE, data.frame(accuracy(fcast, segment))$MAPE)
}

stl_smooth_plot + ggtitle("STL forecast of adjusted smoothed (.10) red cell sales month by month") +
  scale_x_discrete(limits=c(2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018)) + xlab("Time") +
  ylab("Unit sales") + autolayer(window(ts.red.adj, start = 2008), colour = FALSE) +
  geom_text(aes(2018, 1000, label = paste("RMSE: ", as.name(mean(stl_smooth_RMSE))))) + 
  geom_text(aes(2018, 1050, label = paste("MAPE: ", as.name(mean(stl_smooth_MAPE))))) +
  geom_text(aes(2018, 1100, label = paste("cMAPE: ", as.name(mean(stl_smooth_cMAPE)))))
```

