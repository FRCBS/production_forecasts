---
title: "Features testing"
author: "Esa Turkulainen"
date: "1/27/2021"
output: html_document
---

```{r setup, echo=FALSE, message=FALSE, warning=FALSE}
# echo "rmarkdown::render('forecast_script_FIN.Rmd', clean=TRUE,output_format='html_document',output_file='results/forecast_script_FIN_20201006.Rmd')" | R --slave

# Set working directory
ROOTDIR <- "~/production_forecasts/src/" # Your directory
DATADIR <- "~/production_forecasts/data/FACS"
HISTORYDIR <- "~/production_forecasts/histories/" # monthly
MONTHLYDIR <- paste0(HISTORYDIR, "monthly_") # monthly
WEEKLYDIR <- paste0(HISTORYDIR, "weekly_") # weekly

knitr::opts_chunk$set(root.dir = ROOTDIR, warning = FALSE, message = FALSE) # No warnings for final output
knitr::opts_knit$set(root.dir = ROOTDIR, warning = FALSE, message = FALSE)

# Colorblind palette
# black, orange, sky blue, green,
# yellow, blue, vermilion, purple
cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", 
                "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

# These colors work server side for now:
palette <- list(1, 1, 1, 0.7, "royalblue2", "deepskyblue1", "darkred", "darkgreen")
names(palette) <- c("alpha80", "alpha95", "alphaSeg", "alphaPred", "fill80", "fill95", "colPred", "colData")
```

```{r imports, message=FALSE, warning=FALSE, echo=FALSE}
library(forecast)
library(ggplot2)
library(ggthemes)
library(gridExtra)
library(knitr)
library(plyr)
library(lubridate)
library(numbers)
library(data.table)
library(R.utils)
library(DT)
library(stringr)
library(hash)
library(htmltools)
library(feasts)
library(tsibble)
library(dplyr)
library(zoo)
library(scales)
library(grid)
library(ggbiplot)
source("pffunctions.R")
# Set rolling window size in years
rw_years <- 3
start_date <- as.Date("2014-01-01")
```

```{r read_files, include = FALSE}
# Get all the files
files <- list.files(path = DATADIR, pattern = "FAC0091_*")  # Character vector of file names

# Compile a dataframe by going over all files
dlist <- list()
for (i in files) {
  # Read a single file to a df called d
  d <- read.delim(file = paste0(DATADIR, "/", i), header = FALSE, sep = ";", stringsAsFactors = FALSE, colClasses = 'character')
  
  if(length(d) == 26){
    d <- d[, !(names(d) %in% c("V10"))]  # The column numbers unfortunately vary between files, so we'll adjust
    }
  
  colnames(d) <- c("V1", "V2", "V3", "V4", "V5", "V6", "V7", "V8", "V9", "V10",
                   "V11", "V12", "V13", "V14", "V15", "V16", "V17", "V18", "V19", "V20",
                   "V21", "V22", "V23", "V24", "V25")  # This is done so as to have easier column handling later on
  dlist[[i]] <- d
}

d <- as.data.frame(rbindlist(dlist, fill = TRUE))
```

```{r modify_dataframe, include = FALSE}
# Divide into distributions (P) and returns (R)
P <- d[d$V1 == "P", ]
R <- d[d$V1 == "R", ]

# For distributions, we'll keep Distribution date, Quantity, ABO type, Volume, Exp date
keep <- c("V12", "V14", "V18", "V20", "V22", "V24")
distr <- P[keep]
colnames(distr) <- c("date", "product", "quantity", "ABO", "volume", "exp")

# For returns we keep the return date and quantity
keep <- c("V4", "V5", "V7")
retrn <- R[keep]
colnames(retrn) <- c("date", "product", "quantity")

# Datify
distr$date <- dmy(distr$date); distr$exp <- dmy(distr$exp)
retrn$date <- dmy(retrn$date)

# Numerify
distr$quantity <- as.numeric(distr$quantity); distr$volume <- as.numeric(distr$volume)
retrn$quantity <- as.numeric(retrn$quantity)

# Product codes for red cell products
red.codes <- c("budTR001", "A0071V00", "A0074V00", "A0092VA0", "A0092VB0", 
               "E3844V00", "E3845V00", "E3846VA0", "E3846VB0", "E3846VC0",
               "E3846V00", "E3847VA0", "E3847VB0", "E3847VC0", "E3847V00",
               "E3936VA0", "E3936VB0", "E3939V00", "E3940V00", "E4683V00",
               "E7668V00", "E7673V00", "E4999V00", "E5000V00")

red.distr <- distr[distr$product %in% red.codes, ]
red.retrn <- retrn[retrn$product %in% red.codes, ]

# Product codes for platelets
plat.codes <- c("budTR002", "trEnnApu", "A0004V00", "A0005V00", "A0006V00", "A0007V00", "A0008V00",
                "A0086VA0", "A0086VB0", "A0086V00", "A0088V00", "A0088VA0", "A0088VB0", "A0089V00",
                "A0089VB0", "A0089VA0", "A0090V00", "A0090VA0", "A0090VB0", "A0018V00", "A0020V00", 
                "A0021V00", "A0021VA0", "A0021VB0", "A0047V00", "A0049V00", "A0051V00", "A0054V00",
                "A0055V00", "A0056V00", "A0057V00", "A0059V00", "A0060V00", "A0067VA0", "A0067VB0",
                "A0067V00", "A0068VA0", "A0068VB0", "A0068V00", "A0075V00", "A0101V00", "A0102V00",
                "E3949V00", "E3953V00", "E3954V00", "E3955V00", "E3956V00", "E3957V00", "E3958V00",
                "E3959V00", "E3960V00", "E3961V00", "E3962V00", "E3963V00", "E3964V00", "E3965V00", 
                "E3966V00", "E3968VA0", "E3968VB0", "E3968V00", "E3970V00", "E3971V00", "E3973V00",
                "E3974V00", "E3976V00", "E3981V00", "E3995V00", "E3996V00", "E3997V00", "E3997VA0",
                "E3997VB0", "E4002V00", "E4004V00", "E6782V00", "E6783V00", "E6953V00", "E6860V00",
                "E6874VA0", "E6874V00", "E6874VB0", "E6875VB0", "E6875V00", "E7530V00", "E7530VA0",
                "E7530VB0", "E7531V00", "E7531VA0", "E7531VB0", "E6875VA0")

plat.distr <- distr[distr$product %in% plat.codes, ]
plat.retrn <- retrn[retrn$product %in% plat.codes, ]
```

#Get monthly values summarised by Laura
```{r}
monthly2004 <- read.delim("~/production_forecasts/data/kuukausimyynti.txt")
monthly2004$year <- as.factor(substr(monthly2004$kuukausi, 1, 4))
m2004 <- as.factor(substr(monthly2004$kuukausi, 6, 9))
levels(m2004) <- c(8, 7, 2, 4, 12, 6, 10, 3, 11, 9, 1, 5)
monthly2004$month <- as.character(m2004)
```

```{r create_datasets, include = FALSE}
# Create a full sequence of dates for imputation purposes
all.dates <- (seq.Date(min(red.distr$date),
                       max(red.distr$date),
                       "day"))
###           ###
#   RED CELLS   #
###           ###
all.red <- aggregate(red.distr$quantity, by = list(red.distr$date), sum); colnames(all.red) <- c("date", "pcs")
# Merge into a whole set with NAs
all.red <- merge(x = data.frame(date = all.dates),
                 y = all.red,
                 all.x = TRUE)
# Replace with zeroes
all.red[is.na(all.red)] <- 0
# Cut to time after 2014
all.red <- all.red[all.red$date >= start_date, ]

###           ###
#  RED RETURNS  #
###           ###

all.red.retrn <- aggregate(red.retrn$quantity, by = list(red.retrn$date), sum); colnames(all.red.retrn) <- c("date", "pcs")
# Merge into a whole set with NAs
all.red.retrn <- merge(x = data.frame(date = all.dates),
                 y = all.red.retrn,
                 all.x = TRUE)
# Replace with zeroes
all.red.retrn[is.na(all.red.retrn)] <- 0
# Cut to time after 2014
all.red.retrn <- all.red.retrn[all.red.retrn$date >= start_date, ]


# Extracting types
Ominus.distr <- extract_type(red.distr, "O -",start_date)  # This our custom function, see pffunctions.R
Oplus.distr <- extract_type(red.distr, "O +",start_date)
Aminus.distr <- extract_type(red.distr, "A -",start_date)
Aplus.distr <- extract_type(red.distr, "A +",start_date)
Bminus.distr <- extract_type(red.distr, "B -",start_date)
Bplus.distr <- extract_type(red.distr, "B +",start_date)
ABminus.distr <- extract_type(red.distr, "AB-",start_date)
ABplus.distr <- extract_type(red.distr, "AB+",start_date)


###           ###
#   PLATELETS   #
###           ###
all.plat <- aggregate(plat.distr$quantity, by = list(plat.distr$date), sum); colnames(all.plat) <- c("date", "pcs")
# Merge into a whole set with NAs
all.plat <- merge(x = data.frame(date = all.dates),
                  y = all.plat,
                  all.x = TRUE)
# Replace with zeroes
all.plat[is.na(all.plat)] <- 0
# Cut to time after 2014
all.plat <- all.plat[all.plat$date >= start_date, ]

###           ###
# PLAT RETURNS  #
###           ###
all.plat.retrn <- aggregate(plat.retrn$quantity, by = list(plat.retrn$date), sum); colnames(all.plat.retrn) <- c("date", "pcs")
# Merge into a whole set with NAs
all.plat.retrn <- merge(x = data.frame(date = all.dates),
                  y = all.plat.retrn,
                  all.x = TRUE)
# Replace with zeroes
all.plat.retrn[is.na(all.plat.retrn)] <- 0
# Cut to time after 2014
all.plat.retrn <- all.plat.retrn[all.plat.retrn$date >= start_date, ]
```

```{r datasets_monthly, include = FALSE, warning = FALSE}
# Aggregate all by months
red.monthly <- aggregate(pcs ~ month(date) + year(date), data = all.red, FUN = sum)
red.retrn.monthly <- aggregate(pcs ~ month(date) + year(date), data = all.red.retrn, FUN = sum)

Ominus.monthly <- aggregate(pcs ~ month(date) + year(date), data = Ominus.distr, FUN = sum)
Oplus.monthly <- aggregate(pcs ~ month(date) + year(date), data = Oplus.distr, FUN = sum)
Aminus.monthly <- aggregate(pcs ~ month(date) + year(date), data = Aminus.distr, FUN = sum)
Aplus.monthly <- aggregate(pcs ~ month(date) + year(date), data = Aplus.distr, FUN = sum)
Bminus.monthly <- aggregate(pcs ~ month(date) + year(date), data = Bminus.distr, FUN = sum)
Bplus.monthly <- aggregate(pcs ~ month(date) + year(date), data = Bplus.distr, FUN = sum)
ABminus.monthly <- aggregate(pcs ~ month(date) + year(date), data = ABminus.distr, FUN = sum)
ABplus.monthly <- aggregate(pcs ~ month(date) + year(date), data = ABplus.distr, FUN = sum)

plat.monthly <- aggregate(pcs ~ month(date) + year(date), data = all.plat, FUN = sum)
plat.retrn.monthly <- aggregate(pcs ~ month(date) + year(date), data = all.plat.retrn, FUN = sum)

red.monthly$pcs <- red.monthly$pcs - red.retrn.monthly$pcs
plat.monthly$pcs <- plat.monthly$pcs - plat.retrn.monthly$pcs

# Format month level data
red.2004 <- monthly2004[, c("month", "year", "Punasoluvalmisteet")]
colnames(red.2004) <- colnames(red.monthly)
red.2004$`month(date)` <- as.integer(red.2004$`month(date)`)
red.2004$`year(date)` <- as.integer(as.character(red.2004$`year(date)`))
red.2004<- red.2004[order(red.2004$`year(date)`, red.2004$`month(date)`),]
red.2004$Date<- as.Date(as.yearmon(paste0(red.2004$`year(date)`, '-', red.2004$`month(date)`)))
#Reduce returns from returns from deliveries to make numbers actual sales
red.monthly$Date<- as.Date(as.yearmon(paste0(red.monthly$`year(date)`, '-', red.monthly$`month(date)`)))

plat.2004 <- monthly2004[,c("month", "year", "Trombosyyttivalmisteet")]
colnames(plat.2004) <- colnames(plat.monthly)
plat.2004$`month(date)` <- as.integer(plat.2004$`month(date)`)
plat.2004$`year(date)` <- as.integer(as.character(plat.2004$`year(date)`))
plat.2004<- plat.2004[order(plat.2004$`year(date)`,plat.2004$`month(date)`),]
plat.2004$Date<- as.Date(as.yearmon(paste0(plat.2004$`year(date)`, '-', plat.2004$`month(date)`)))
plat.monthly$Date<- as.Date(as.yearmon(paste0(plat.monthly$`year(date)`, '-', plat.monthly$`month(date)`)))

# Glue together
red.monthly <- rbind(red.2004[red.2004$Date < as.Date("2019-01-01") ,],
                     red.monthly[red.monthly$Date >= as.Date("2019-01-01") & red.monthly$Date < as.Date("2020-08-01")  ,])
plat.monthly <- rbind(plat.2004[plat.2004$Date < as.Date("2019-01-01") ,],
                      plat.monthly[plat.monthly$Date >= as.Date("2019-01-01") & plat.monthly$Date < as.Date("2020-08-01")  ,])

# Dates
#months <- seq(from = as.Date("2009-01-01"), to = max(distr$date), by = "month")
months <- seq(from = as.Date("2004-01-01"), to = max(red.monthly$Date), by = "month") # This needs to be tuned based on your data set

# Adjustment series
adj <- as.numeric(bizdays(ts(months, 
                             start = c(2004, 1, 1), #  c(year, month, day) is apparently the only robust way to do this.
                             frequency = 12), FinCenter = "Zurich"))

# scaler <- as.numeric(bizdays(ts(1, start = decimal_date(months[length(months)]), frequency = 12), FinCenter = "Zurich")) This was written to scale a singular forecasted month back to real values, for saving-to-file purposes

end_date <- months[length(months)] # Ugly but around 30 times faster than tail(x, 1)!
reverse_adj <- as.numeric(bizdays(ts(seq(23), 
                                     start = c(year(end_date), month(end_date), day(end_date)), 
                                     frequency = 12), FinCenter = "Zurich")) # This is the old implementation that used to be fed into the forecasting function. We'll now repurpose it so it can be used both for tabling and plotting.

# Create a master frame
monthly <- data.frame(date = months,
                      red = red.monthly$pcs/adj,
                      plat = plat.monthly$pcs/adj)

monthly_real <- data.frame(date = months,
                           red = red.monthly$pcs,
                           plat = plat.monthly$pcs)
```

# POISTA TÄMÄ SOLU
```{r}
# TODO: del
write.csv(monthly_real, file = "/home/esa/production_forecasts/data/monthly_real_2004.csv", row.names = FALSE)
```


Feature extraction using feasts
```{r}
start_init <- as.Date("2004-01-01") # segment origin
end_init <- as.Date("2012-01-01") # segment terminus
end_of_time <- monthly$date[length(monthly$date)] - months(3)
nmonths <- 12 * (year(end_of_time) - year(end_init)) + (month(end_of_time) - month(end_init))

metricvec <- c()
for(i in 0:nmonths){
  start_date <- start_init + months(i)  # inclusive
  end_date <- end_init + months(i)     # exclusive
  segment <- as_tsibble(ts(monthly$red[monthly$date >= start_date & monthly$date < end_date], 
                start = c(year(start_date), month(start_date), day(start_date)), frequency = 12))
  temp <- cbind(features(segment, value, features = feature_set(pkgs = NULL, tags = NULL)), data.frame(endyear = year(end_date)))
  metricvec <- append(metricvec, temp)
}
```


```{r, warning=FALSE}
metrics <- data.frame(matrix(unlist(metricvec), ncol=49, byrow=TRUE), stringsAsFactors=FALSE)
colnames(metrics) <- names(metricvec)[1:49]
metrics <- select(metrics, c("trend_strength", "seasonal_strength_year", "spikiness",
                             "linearity", "curvature", "diff1_acf1", "diff2_acf1",
                             "lambda_guerrero", "shift_kl_max", "shift_var_max",
                             "shift_level_max", "diff1_pacf5", "diff2_pacf5", "season_acf1",
                             "season_pacf", "var_tiled_var", "stat_arch_lm", "endyear"))

out_ind <- c()
for(i in 1:dim(metrics)[2]){
  out_ind <- append(out_ind, which(metrics[[i]] == boxplot.stats(metrics[[i]])$out))
}
nonout_metrics <- metrics[-out_ind, ]
nonzerovar_metrics <- nonout_metrics[ , apply(nonout_metrics, 2, var, na.rm=TRUE) != 0]
filtered_metrics <- subset(nonzerovar_metrics, select = -c(endyear))
```


tmp <- cor(filtered_metrics)
tmp[!lower.tri(tmp)] <- 0

noncor_metrics <- filtered_metrics[, !apply(tmp, 2, function(x) any(abs(x) > 0.89))]

```{r}
metrics.pa <- prcomp(filtered_metrics, center = TRUE, scale. = TRUE)
```

```{r}
summary(metrics.pa)
```

```{r}
metrics.pa$rotation
```

```{r}
ggbiplot(metrics.pa, choices = 1:2, groups = nonzerovar_metrics$endyear, var.axes = FALSE)
```

```{r}
rotations <- metrics.pa$rotation
top12names <- append(names(rotations[, "PC1"][order(abs(rotations[ , "PC1"]), decreasing = TRUE)[1:6]]), names(rotations[, "PC2"][order(abs(rotations[ , "PC2"]), decreasing = TRUE)[1:6]]))
```

```{r}
top12 <- metrics[, top12names]
plots <- lapply(1:12, FUN = function(x) {
  ggplot(data = top12) + 
    geom_line(aes(x = 1:length(top12[, x]), y = top12[ , x]), size = 1.2, color = "midnightblue", inherit.aes = FALSE) +
    labs(x="Months since origin", y="Value", title = colnames(top12)[x]) +
    theme_minimal()
})
```

```{r}
plots[[1]]
plots[[2]]
plots[[3]]
plots[[4]]
plots[[5]]
plots[[6]]
plots[[7]]
plots[[8]]
plots[[9]]
plots[[10]]
plots[[11]] 
#plots[[12]] # 6th heaviest in PC2 is the same as the 4th heaviest in PC1
```
```{r}
w <- summary(metrics.pa)$importance[2, ]
rots <- abs(metrics.pa$rotation)
```

```{r}
scaled_rots <- sweep(rots, 2, colSums(rots), "/")
reweighted_rots <- sweep(scaled_rots, 2, w, "*")
feat_weights <- rowSums(reweighted_rots)
```

```{r}
ord_weights <- feat_weights[order(feat_weights, decreasing = TRUE)]
plot(ord_weights)
```
```{r}
ord_weights
```
```{r}
ordnames <- names(ord_weights)
ordnames
top12names
```
```{r}
top6 <- metrics[, ordnames[1:6]]
plots <- lapply(1:6, FUN = function(x) {
  ggplot(data = top6) + 
    geom_line(aes(x = 1:length(top6[, x]), y = top6[ , x]), size = 1.2, color = "midnightblue", inherit.aes = FALSE) +
    labs(x="Months since origin", y="Value", title = colnames(top6)[x]) +
    theme_minimal()
})
```

```{r}
plots[[1]]
plots[[2]]
plots[[3]]
plots[[4]]
plots[[5]]
plots[[6]]
```

## Divide series into segments and find means for a couple / handful of features.

```{r}
series <- select(monthly, c("date", "red"))
```

```{r}
df1 <- series[1:66, ]
df2 <- series[67:132, ]
df3 <- series[133:199, ]
equal_three <- list(df1 = df1,
                    df2 = df2,
                    df3 = df3)
```


### Let's test this idea with Trend, Seasonality, and Linearity

This might not work conceptually, as the size of the optimal rolling window for NL was around 7 years?

```{r}
feat_tags <- c("trend_strength", "seasonal_strength_year", "linearity")  # for selection
feat_names <- c("Trend", "Seasonality (yearly)", "Linearity")            # for plots and tables

# Iterate list of time periods
datalist <- list()
for(i in 1:length(equal_three)){
  df <- equal_three[[i]]
  # Define segment as a tsibble object
  segment <- as_tsibble(ts(df$red, start = c(year(df$date[1]), month(df$date[1]), day(df$date[1])), frequency = 12))
  
  # Compute features with feasts
  feats <- select(features(segment, value, list(feat_stl)), feat_tags)
  value <- as.numeric(feats) # TODO: check from somewhere if feat selection can be done explicitly
  feature <- names(feats)
  until <- rep(paste0(year(df$date[length(df$date)]), "-", month(df$date[length(df$date)])), 3)
  temp <- data.frame(feature, value, until)
  datalist[[i]] <- temp
}

feat_df <- do.call(rbind, datalist)

# Check
feat_df
```

```{r}
# Scale for plotting
feat_df[which(feat_df[, "feature"] == "trend_strength"), ]$value <- scale(feat_df[which(feat_df[, "feature"] == "trend_strength"), ]$value)
feat_df[which(feat_df[, "feature"] == "seasonal_strength_year"), ]$value <- scale(feat_df[which(feat_df[, "feature"] == "seasonal_strength_year"), ]$value)
feat_df[which(feat_df[, "feature"] == "linearity"), ]$value <- scale(feat_df[which(feat_df[, "feature"] == "linearity"), ]$value)

# Grouped
ggplot(feat_df, aes(fill = until, y = value, x = feature)) + 
  geom_bar(position="dodge", stat="identity") + 
  theme_minimal() +
  scale_x_discrete(limits = feat_tags, labels = feat_names) +
  scale_fill_brewer(palette = "Reds") + # Needs to withstand color blindness, bw printing and photocopy
  labs(title = "Series features in three equally sized periods", 
       subtitle = paste0("Data extends from ", 
                         year(monthly$date[1]), 
                         " to ",
                         year(monthly$date[length(monthly$date)]),
                         ". Feature values centered and scaled to [-1, 1]."),
       y = "Value", x = "Feature", fill = "Until") +
  theme(plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5))
```
```{r}
beginning <- df1$date[1]
series.ts <- ts(df1$red, start = c(year(beginning), month(beginning), day(beginning)), frequency = 12)
selected_model <- select_model(beginning, series.ts, freq = "monthly", rw_years = 3)
```

```{r}
modelnames <- c("SNAIVE", "5-MA", "7-MA", "9-MA", "12-MA", "STL", "ETS", "TBATS", "STLF", "ARIMAX", "DYNREG", "NN", "COMBINED")
modelnames[selected_model]
```

```{r}
beginning <- df2$date[1]
series.ts <- ts(df2$red, start = c(year(beginning), month(beginning), day(beginning)), frequency = 12)
selected_model <- select_model(beginning, series.ts, freq = "monthly", rw_years = 3)
```

```{r}
modelnames <- c("SNAIVE", "5-MA", "7-MA", "9-MA", "12-MA", "STL", "ETS", "TBATS", "STLF", "ARIMAX", "DYNREG", "NN", "COMBINED")
modelnames[selected_model]
```

```{r}
beginning <- df3$date[1]
series.ts <- ts(df3$red, start = c(year(beginning), month(beginning), day(beginning)), frequency = 12)
selected_model <- select_model(beginning, series.ts, freq = "monthly", rw_years = 3)
```

```{r}
modelnames <- c("SNAIVE", "5-MA", "7-MA", "9-MA", "12-MA", "STL", "ETS", "TBATS", "STLF", "ARIMAX", "DYNREG", "NN", "COMBINED")
modelnames[selected_model]
```

## Another idea is to simply display the change in the frequency distribution of selected models over time

For this, we'll need to generate monthly histories throughout the entire series.
```{r}
# monthly <- read.csv("/home/esa/production_forecasts/data/monthly_2014.csv")
# monthly$date <- as.Date(monthly$date)
# history <- monthly # variable change so we can use our pre-existing code
# rw_years <- 3 # ensure 3 yr rolling window
# type <- "red"
# 
# N <- length(history$date) - 12 * (rw_years + 1) # Preallocate rows
# forecast.history <- data.frame(time = rep(as.Date(tail(history$date, (rw_years + 1) * 12)[1]), N),
#                                model = rep("", N),
#                                forecast = rep(NA, N),
#                                upper80 = rep(NA, N),
#                                upper95 = rep(NA, N),
#                                lower80 = rep(NA, N),
#                                lower95 = rep(NA, N),
#                                stringsAsFactors = F)
# 
# pb = txtProgressBar(min = 0, max = N, initial = 0, style = 3) # Progress Bar for fun
# 
# for(i in seq(0, (N - 1))){
#   cutreal <- head(history, -(N - i)) # Erase (N-x) months from real history
#   beginning <- tail(cutreal$date, (((rw_years + 1) * 12) + 1))[1] # Define beginning of window
#   segment <- head(tail(cutreal[, type], (((rw_years + 1) * 12) + 1)), ((rw_years + 1) * 12)) # Define window
#   series.ts <- ts(segment, start = c(year(beginning), month(beginning), day(beginning)), frequency = 12) # Transform into a ts object
# 
#   scale_start <- cutreal$date[length(cutreal$date)]
#   scaleback <- as.numeric(bizdays(ts(seq(1),
#                                      start = c(year(scale_start), month(scale_start), day(scale_start)),
#                                      frequency = 12), FinCenter = "Zurich")) # Scaler for saving
# 
#   # Forecast
#   chosen.model <- select_model(beginning, series.ts, freq = "monthly", rw_years) # Choose model
#   mcast <- chosen_forecast(chosen.model, series.ts, history, freq = "monthly", rw_years) # Output a forecast
#   missing.fcast <- data.frame(time = tail(cutreal$date, 1),
#                               model = modelnames[chosen.model],
#                               forecast = mcast$fcast[1] * scaleback,
#                               upper80 = mcast$upper80[1] * scaleback,
#                               upper95 = mcast$upper95[1] * scaleback,
#                               lower80 = mcast$lower80[1] * scaleback,
#                               lower95 = mcast$lower95[1] * scaleback, stringsAsFactors = FALSE)
#   forecast.history[(i+1), ] <- missing.fcast
#   setTxtProgressBar(pb, i) # Update progress bar
# }
# 
# # Save into a csv
# write.csv(forecast.history, file = "/home/esa/production_forecasts/histories/long_fcast_history_invtest.csv", row.names = FALSE)
```

## Draw frequency plot
```{r}
# Load history
data <- read.csv("/home/esa/production_forecasts/histories/long_fcast_history.csv")
head(data)
```

```{r}
first_half <- data[1:75, 1:2]
second_half <- data[76:151, 1:2]
```

```{r}
ggplot(data = first_half, aes(model)) + geom_histogram(stat = "count") + theme_minimal()
```
```{r}
ggplot(data = second_half, aes(model)) + geom_histogram(stat = "count") + theme_minimal()
```

