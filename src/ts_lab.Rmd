---
title: 'Forecasting Lab: Production Figures'
output: github_document
---

Tässä dokumentissa tutkitaan aikasarjaennustamista tuotannon kuukausittaisilla luvuilla. Erityisesti halutaan tietää seuraavat:

1. Kuinka hyvin ennustemallit ovat historiallisesti toimineet? Onko jompi kumpi malleista parempi?
1.1. Kuinka hyvä keskiarvoennuste on?
1.2. Kuinka hyvin vaihtelu mahtuu ennustettuihin rajoihin? Onko yksittäisiä selitettäviä poikkeamia?
1.3. Miten parametrien valinta vaikuttaa mallien suoriutumiseen (esim. ikkunan koko)?
2. Voidaanko tehdä kuukausiennuste tulevaisuuteen?
3. Onko olemassa uusia ja parempia helposti sovellettavia malleja?
4. Saisiko malleihin lisää parametreja?
4.1. Työpäivien määrä kuukaudessa
4.2. Historiallinen vuosivaihtelu
4.3. Priori yleisestä trendistä
4.4. Väestörakenne
4.4.1 Auttaako sairaanhoitopiirien tasolle meneminen?

## Create original dataset that should remain immutable throughout labbing
```{r message=FALSE}
library(forecast)
library(ggplot2)
library(gridExtra)

# Set working directory and load data
setwd("/home/esa/production_forecasts")
monthly_sales <- read.table("/home/esa/production_forecasts/data/kuukausimyynti.txt", header = T, sep = "\t")

# Separate yyyy/mmm column into months and years
monthly_sales$year <- substr(monthly_sales$kuukausi, 1, 4)
monthly_sales$month <- factor(substr(monthly_sales$kuukausi, 6, 8), levels=c("tam", "hel", "maa", "huh", "tou", "kes", "hei", "elo", "syy", "lok", "mar", "jou"))

# Create a numeric column for months
monthly_sales$month_num <- as.numeric(monthly_sales$month)

# Omit empty values
d <- na.omit(monthly_sales)
```

## Create time series objects
```{r}
ts.red <- ts(d$Punasoluvalmisteet, 
             start=as.numeric(c(d$year[1], d$month_num[1])), 
             end=as.numeric(c(tail(d$year, 1), tail(d$month_num, 1))), 
             frequency=12)  # This tells the series that it is monthly data
ts.pla <- ts(d$Trombosyyttivalmisteet,
             start=as.numeric(c(d$year[1], d$month_num[1])), 
             end=as.numeric(c(tail(d$year, 1), tail(d$month_num, 1))), 
             frequency=12)
ts.ffp <- ts(d$FFP,
             start=as.numeric(c(d$year[1], d$month_num[1])), 
             end=as.numeric(c(tail(d$year, 1), tail(d$month_num, 1))), 
             frequency=12)

# Create plots for a quick overview
tsm <- cbind(ts.red, ts.pla, ts.ffp)
p1 <- autoplot(ts.red)
p2 <- autoplot(ts.pla)
p3 <- autoplot(ts.ffp)
p4 <- autoplot(tsm)
grid.arrange(grobs=list(p1, p2, p3, p4), 
             widths=c(4, 2, 2), 
             layout_matrix = rbind(c(4, 1, 2), 
                                   c(4, 3, NA)))
```
Tähän perään tulee dekompositioita ja "transformaatioita" myöhemmin.


## Forecasts of Jarno Tuimala
```{r}
# Seasonal Decomposition by LOESS
# The t.window of stl() should be an odd number, but Tuimala has decided against it. Will investigate.
stl.red <- forecast(stl(ts.red, s.window="periodic", t.window=6), h=12)
stl.pla <- forecast(stl(ts.pla, s.window="periodic", t.window=6), h=12)
stl.ffp <- forecast(stl(ts.ffp, s.window="periodic", t.window=6), h=12)

# Exponential smoothing state space model
# ets() is an automated model selection function, so these are not the same model! Uses AICc, AIC and BIC.
ets.red <- forecast(ets(ts.red), h=12)
ets.pla <- forecast(ets(ts.pla), h=12)
ets.ffp <- forecast(ets(ts.ffp), h=12)

# Plot
par(mfcol=c(3, 2))
plot(stl.red)
plot(stl.pla)
plot(stl.ffp)
plot(ets.red)
plot(ets.pla)
plot(ets.ffp)
```

## Check the errors of yearly and monthly predictions. 
```{r}
yearly <- ggplot() 
forecast_errors <- c()
# Loop 
for(i in seq(from=2008, to=2018, by=1)){
  fit <- stl(window(ts.red, start=2004, end=c(i-1, 12)), s.window="periodic", t.window=6)  # Fit based on history so far
  fcast <- forecast(fit, h=12)  # Forecast the next year
  segment <- window(ts.red, start=i, end=c(i, 12))  # Extract that year from the history for plotting purposes
  
  # Build the plot piece by piece
  yearly <- yearly + autolayer(fcast) + autolayer(segment, colour=FALSE)
  
  # Calculate forecast errors
  forecast_errors <- c(forecast_errors, abs(data.frame(fcast)$Point.Forecast - segment))
}

yearly + ggtitle("STL+ETS forecast of red cell sales year by year") +
  scale_x_discrete(limits=c(2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018)) + xlab("Time") +
  ylab("Unit sales")
```
```{r}
autoplot(ts(forecast_errors, start=2008, end=2018, frequency=12)) + ggtitle("STL+ETS historical forecast errors") + ylab("Unit sales")
```

```{r}
yearly_ets <- ggplot() 
ets_forecast_errors <- c()
# Loop 
for(i in seq(from=2008, to=2018, by=1)){
  fit <- ets(window(ts.red, start=2004, end=c(i-1, 12)))  # Fit based on history so far
  fcast <- forecast(fit, h=12)  # Forecast the next year
  segment <- window(ts.red, start=i, end=c(i, 12))  # Extract that year from the history for plotting purposes
  
  # Build the plot piece by piece
  yearly_ets <- yearly_ets + autolayer(fcast) + autolayer(segment, colour=FALSE)
  
  # Calculate forecast errors
  ets_forecast_errors <- c(ets_forecast_errors, abs(data.frame(fcast)$Point.Forecast - segment))
}

yearly_ets + ggtitle("ETS forecast of red cell sales year by year") +
  scale_x_discrete(limits=c(2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018)) + xlab("Time") +
  ylab("Unit sales")
```
```{r}
autoplot(ts(ets_forecast_errors, start=2008, end=2018, frequency=12)) + ggtitle("ETS historical forecast errors") + ylab("Unit sales")
```

Find out which performed better on average:
```{r}
median(forecast_errors)
median(ets_forecast_errors)
```
It is noteworthy that after 2011 the models have been identical!

## Investigating the seasonality and trend of the series
```{r}
library(TSA)

pgram <- periodogram(ts.red)

dd = data.frame(freq=pgram$freq, spec=pgram$spec)
order = dd[order(-dd$spec),]
top2 = head(order, 10)
 
# display the 2 highest "power" frequencies
top2
```


## Using a decomposition
```{r}
decomposed <- stl(ts.red, s.window="periodic")
plot(decomposed)
```

```{r}
seasonal   <- decomposed$time.series[,1]
trend	   <- decomposed$time.series[,2]
remainder  <- decomposed$time.series[,3]

par(mfcol = c(3, 1))
plot(trend+remainder,
     main="Red cell production over Time, Seasonally Adjusted",
     ylab="Red cell production (units)")
plot(seasonal+remainder,
     main="Red cell production over Time, Trend Adjusted",
     ylab="Red cell production (units")
plot(trend+seasonal,
     main="Red cell production over Time, Noise removed",
     ylab="Red cell production (units")
```
## Test noise to see if decomposition is successful
```{r}
checkresiduals(remainder)
```
Something suspicious about this decomp. Let's observe the seasons more closely.

## Seasonal plot
```{r}
library(ggplot2)
ggseasonplot(ts.red, year.labels = TRUE, year.labels.left = TRUE)
ggseasonplot(ts.pla, year.labels = TRUE, year.labels.left = TRUE)
ggseasonplot(ts.ffp, year.labels = TRUE, year.labels.left = TRUE)

```
```{r}
ggsubseriesplot(ts.red)
```
## Do blood product types correlate with each other?
```{r}
GGally::ggpairs(as.data.frame(cbind(ts.red, ts.pla, ts.ffp)))
```
```{r}
ggAcf(ts.red)
```
## Playing around with a NN
```{r}
library(ggplot2)
fit <- nnetar(ts.red, lambda=0)
autoplot(forecast(fit, PI=TRUE, h=12))
```

