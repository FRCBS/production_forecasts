---
title: "Forecasting Script"
output: 
    html_document:
        includes:
            before_body: header.html
---

```{r setup, echo=FALSE, message=FALSE, warning=FALSE}
# Set working directory or whatever you need
WDIR <- "~/production_forecasts/"
setwd(WDIR)
```

```{r imports_and_global, message=FALSE, warning=FALSE, echo=FALSE}
source("~/production_forecasts/src/implementation/report_functions.R")
library(forecast)
library(lubridate)
library(ggplot2)

# Set (rolling) training window size in years
RW_YEARS <- 2
# Set testing period length (in whatever time resolution you use)
TESTP <- 12
# Now resolution as an explicit variable
RES <- "weekly"
# Length of forecast horizon
N <- 4
# List other possibly useful horizons here
M <- 12
```

```{r load_data, message=FALSE, warning=FALSE, echo=FALSE}
# If your data comes directly from a BI server, you will need to manipulate it here
# E.g. files <- list.files(path = DATADIR, pattern = "FILE_ID_2022-01-01_*")
#      for (i in files) { do: compile into a dataframe }  

# If your data comes pre-processed in the desired resolution (e.g. individual instances to daily/weekly/monthly sums)
# load it here.
red_weekly <- read.csv("~/production_forecasts/dummy_data/dummy_weekly_red.csv", colClasses = c("Date", "numeric"))
Ominus_weekly <- read.csv("~/production_forecasts/dummy_data/dummy_weekly_Ominus.csv", colClasses = c("Date", "numeric"))
# plat_weekly <- read.csv("DATADIR/plat_weekly.csv", colClasses = c("Date", "numeric"))
# ...

# This script assumes the following data structure
# |    date    |  pcs  |
# | 2022-01-01 |  200  |
# | 2022-01-08 |  300  |
# etc...
```

```{r note1, message=FALSE, warning=FALSE, echo=FALSE}
# Customize SECTION TITLE (below) to your needs
```

## `r N` week forecast {.tabset .tabset-fade .tabset-pills}

```{r note2, message=FALSE, warning=FALSE, echo=FALSE}
# Below we setup tab structure for the report.
# These constitute as tabs inside the HTML document and they operate under the SECTION TITLE
```

### All red

```{r red_forecast, echo = FALSE, results = FALSE, message=FALSE, warning=FALSE}
# Autonomous forecasting utilizes method selection heuristics that look at
# previous method performance. To reduce the computational burden, historical
# method performances are saved into a file.
# 
# If your data is MONTHLY, it is probably affected
# by the number of workdays in each month. To adjust
# for this, we can use the bizdays() function from the
# forecast package:
if (RES == "monthly") {
    start_date <- red_monthly[1, 1] # For adjusting the series
    fcast_start_date <- red_monthly[nrow(red_monthly), 1] + months(1) # For adjusting the forecast
    series_workdays <- as.numeric(bizdays(ts(1:nrow(red_monthly), start = c(year(start_date), month(start_date), day(start_date)),
                                             frequency = 12), 
                                          FinCenter = "Zurich")) # Select the most appropriate FinCenter for you
    fcast_workdays <- as.numeric(bizdays(ts(1:N, start = c(year(start_date), month(start_date), day(start_date)), 
                                            frequency = 12),
                                         FinCenter = "Zurich"))
    # Adjust series
    series <- cbind(red_monthly[, 1], (red_monthly[, 2] / series_workdays))
} else {
    series <- red_weekly
}
# 
# select_method will generate and save 
# performance history if it doesn't exist.
# Check report_functions() for heur options.
selected_method <- select_method(series, path = "~/production_forecasts/dummy_data/all_fcasts_history_weekly_red.csv", heur = TESTP, res = RES, rw_years = RW_YEARS)  # Note that you may need to remember change filenames if they contain time resolution information, when changing resolutions

# The selected method is now used to generate
# N (user determined number) forecasts into the future
forecast <- get_forecast(series, selected_method, h = N, res = RES, rw_years = 2, alpha = 0.5, path = "~/production_forecasts/dummy_data/all_fcasts_history_weekly_red.csv")

# Again, if your data is MONTHLY, 
# the adjustment needs to be reversed.
if (RES == "monthly") {
    forecast <- forecast * fcast_workdays
}

# Save only the next day/week/month/year forecast into selected forecast history file:
# AND ONLY IF it doesn't exist already
if (RES == "daily") { fcast_date <- series[nrow(series), 1] +  days(1) }
if (RES == "weekly") { fcast_date <- series[nrow(series), 1] +  weeks(1) }
if (RES == "monthly") { fcast_date <- series[nrow(series), 1] +  months(1) }
if (RES == "yearly") { fcast_date <- series[nrow(series), 1] +  years(1) }

if (!(file.exists("~/production_forecasts/dummy_data/weekly_forecasts_red.csv"))) { # The file might not exist on the first run
    if (is.list(selected_method)) {methodname <- selected_method$name} else {methodname <- selected_method}
    write.table(data.frame(date = fcast_date, method = methodname, fcast = head(forecast, 1)), 
                file = "~/production_forecasts/dummy_data/weekly_forecasts_red.csv", sep = ",", 
                append = TRUE, row.names = FALSE, col.names = TRUE)
} else {
    last_obs <- tail(read.csv("~/production_forecasts/dummy_data/weekly_forecasts_red.csv"), 1)[, 1]
    if (!(last_obs >= fcast_date)) { # If if it exists AND if last_obs < fcast_date
        if (is.list(selected_method)) {methodname <- selected_method$name} else {methodname <- selected_method}
        write.table(data.frame(date = fcast_date, method = methodname, fcast = head(forecast, 1)), 
                    file = "~/production_forecasts/dummy_data/weekly_forecasts_red.csv", sep = ",", 
                    append = TRUE, row.names = FALSE, col.names = FALSE)
        }
    }

```

```{r plot_red_forecast, fig.align = "center", out.width = '80%', echo = FALSE}
draw_forecast(forecast, series, h = N, res = "weekly", product = "RBC", palette = "colorblind")
```

<style>
div.red { background-color:#ff8080; border-radius: 5px; padding: 20px; font-size: 25px; text-align: center; width: 700px; margin: auto;}
</style>
<div class = "red">

Forecast for week `r as.numeric(week(today()))` of `r year(today())`: `r # Edit these when forecasting something other than weeks.` `r format(round(forecast[1], 0))  # This is to round AND display only whole numbers.` blood bags.

</div>

### O-

```{r Ominus_forecast, echo = FALSE, results = FALSE, message=FALSE, warning=FALSE}
if (RES == "monthly") {
    start_date <- Ominus_monthly[1, 1] # For adjusting the series
    fcast_start_date <- Ominus_monthly[nrow(Ominus_monthly), 1] + days(1) # For adjusting the forecast
    series_workdays <- as.numeric(bizdays(ts(1:nrow(Ominus_monthly), start = c(year(start_date), month(start_date), day(start_date)),
                                             frequency = 12), 
                                          FinCenter = "Zurich")) # Select the most appropriate FinCenter for you
    fcast_workdays <- as.numeric(bizdays(ts(1:N, start = c(year(start_date), month(start_date), day(start_date)), 
                                            frequency = 12),
                                         FinCenter = "Zurich"))
    # Adjust series
    series <- cbind(Ominus_monthly[, 1], (Ominus_monthly[, 2] / series_workdays))
} else {
    series <- Ominus_weekly
}

selected_method <- select_method(series, path = "~/production_forecasts/dummy_data/all_fcasts_history_weekly_Ominus.csv", 
                                 heur = TESTP, res = RES, rw_years = RW_YEARS)
forecast <- get_forecast(series, selected_method, h = N, res = RES, rw_years = 2, alpha = 0.5, 
                         path = "~/production_forecasts/dummy_data/all_fcasts_history_weekly_Ominus.csv")

if (RES == "monthly") {
    forecast <- forecast * fcast_workdays
}

if (RES == "daily") { fcast_date <- series[nrow(series), 1] +  days(1) }
if (RES == "weekly") { fcast_date <- series[nrow(series), 1] +  weeks(1) }
if (RES == "monthly") { fcast_date <- series[nrow(series), 1] +  months(1) }
if (RES == "yearly") { fcast_date <- series[nrow(series), 1] +  years(1) }
if (!(file.exists("~/production_forecasts/dummy_data/weekly_forecasts_Ominus.csv"))) { # The file might not exist on the first run
    if (is.list(selected_method)) {methodname <- selected_method$name} else {methodname <- selected_method}
    write.table(data.frame(date = fcast_date, method = methodname, fcast = head(forecast, 1)), 
                file = "~/production_forecasts/dummy_data/weekly_forecasts_Ominus.csv", sep = ",", 
                append = TRUE, row.names = FALSE, col.names = TRUE)
} else {
    last_obs <- tail(read.csv("~/production_forecasts/dummy_data/weekly_forecasts_Ominus.csv"), 1)[, 1]
    if (!(last_obs >= fcast_date)) { # If if it exists AND if last_obs < fcast_date
        if (is.list(selected_method)) {methodname <- selected_method$name} else {methodname <- selected_method}
        write.table(data.frame(date = fcast_date, method = methodname, fcast = head(forecast, 1)), 
                    file = "~/production_forecasts/dummy_data/weekly_forecasts_Ominus.csv", sep = ",", 
                    append = TRUE, row.names = FALSE, col.names = FALSE)
        }
    }

```

```{r plot_Ominus_forecast, fig.align = "center", out.width = '80%', echo = FALSE}
draw_forecast(forecast, series, h = N, res = "weekly", product = "O-", palette = "colorblind")
```

<style>
div.red {  background-color:#ff8080; border-radius: 5px; padding: 20px; font-size: 25px; text-align: center; width: 700px; margin: auto; }
</style>
<div class = "red">

Forecast for week `r as.numeric(week(today()))` of `r year(today())`: `r # Edit these when forecasting something other than weeks.` `r format(round(forecast[1], 0))  # This is to round AND display only whole numbers.` blood bags.

</div>

***



`r # To begin another section (for another product class, or time resolution), use`

## `r M` year/month/week/day forecast {.tabset .tabset-fade .tabset-pills}

`r # Knit into HTML to view report. Add tables or other content if desired.`
