---
title: "Delivery Lab: Red Cells (all)"
output: github_document
---

```{r setup, echo=FALSE}
# Set working directory
knitr::opts_knit$set(root.dir = "/home/esa/production_forecasts") # Working on Ubuntu
#knitr::opts_knit$set(root.dir = "V:/production_forecasts") # Working home
```

```{r imports, message=FALSE}
library(forecast)
library(ggplot2)
library(gridExtra)
library(knitr)
library(readxl)
library(plyr)
library(lubridate)
library(numbers)
library(data.table)
library(R.utils)
source("src/evalhelp.R")
```

```{r read_files}
# Get all the files
dfold <- "/home/esa/production_forecasts/data/FACS/"
files <- list.files(path = dfold, pattern = "FAC0091_*")

# Compile a dataframe by going over all files
dlist <- list()
for (i in files) {
  # Read a single file to a df called d
  d <- read.delim(file = paste0(dfold, "/", i), header = FALSE, sep = ";", stringsAsFactors = FALSE, colClasses = 'character')
  if(length(d) == 26){
    d <- d[, !(names(d) %in% c("V10"))]  # The column numbers unfortunately vary between files, so we'll adjust
    }
  colnames(d) <- c("V1", "V2", "V3", "V4", "V5", "V6", "V7", "V8", "V9", "V10",
                   "V11", "V12", "V13", "V14", "V15", "V16", "V17", "V18", "V19", "V20",
                   "V21", "V22", "V23", "V24", "V25")  # This is done so as to have easier column handling later on
  dlist[[i]] <- d
}

d <- as.data.frame(rbindlist(dlist, fill = TRUE))

# Sales
sales <- read.table("./data/kuukausimyynti.txt", header = T, sep = "\t")
# Sales data begins January 2004 and ends on April 2019
sales$date <- seq(from = as.Date("2004-01-01"), to = as.Date("2019-04-01"), by = "month")
# We'll be examining only red cells for now, so we'll drop everything we don't need
keep = c("Punasoluvalmisteet", "date")
sales <- sales[keep]
```

```{r modify_dataframe}
# Divide into distributions (P) and returns (R)
P <- d[d$V1 == "P", ]
R <- d[d$V1 == "R", ]

# For distributions, we'll keep Distribution date, Quantity, ABO type, Volume, Exp date
keep <- c("V12", "V14", "V18", "V20", "V22", "V24")
distr <- P[keep]
colnames(distr) <- c("date", "product", "quantity", "ABO", "volume", "exp")

# For returns we keep the return date
keep <- c("V4", "V7")
retrn <- R[keep]
colnames(retrn) <- c("date", "quantity")

# Datify
distr$date <- dmy(distr$date); distr$exp <- dmy(distr$exp)
retrn$date <- dmy(retrn$date)

# Numerify
distr$quantity <- as.numeric(distr$quantity); distr$volume <- as.numeric(distr$volume)
retrn$quantity <- as.numeric(retrn$quantity)
```

```{r}
# Product codes for red cell products
codes <- c("budTR001", "A0071V00", "A0074V00", "A0092VA0", "A0092VB0", 
           "E3844V00", "E3845V00", "E3846VA0", "E3846VB0", "E3846VC0",
           "E3846V00", "E3847VA0", "E3847VB0", "E3847VC0", "E3847V00", 
           "E3936VA0", "E3936VB0", "E3939V00", "E3940V00", "E4683V00",
           "E7668V00", "E7673V00", "E4999V00", "E5000V00")

distr <- distr[distr$product %in% codes, ]
```


```{r create_datasets}
# Create a full sequence of dates for imputation purposes
all.dates <- (seq.Date(min(distr$date),
                       max(distr$date),
                       "day"))

all.distr <- aggregate(distr$quantity, by = list(distr$date), sum); colnames(all.distr) <- c("date", "pcs")
# Merge into a whole set with NAs
# all.distr.other <- merge(x = data.frame(date = all.dates),
#                  y = all.distr,
#                  all.x = TRUE)
# # Replace with zeroes
# all.distr.other[is.na(all.distr.other)] <- 0
# # Cut to time after 2014
# all.distr.other <- all.distr.other[all.distr.other$date >= as.Date("2014-01-01"), ]
all.distr <- all.distr[all.distr$date >= as.Date("2014-01-06"), ]
#all.distr <- aggregate(distr$quantity, by = list(distr$date), sum); colnames(all.distr) <- c("date", "pcs")
all.retrn <- aggregate(retrn$quantity, by = list(retrn$date), sum); colnames(all.retrn) <- c("date", "pcs")

# O minus
Ominus <- distr[distr$ABO == "O -", ]
Ominus.distr <- aggregate(Ominus$quantity, by = list(Ominus$date), sum); colnames(Ominus.distr) <- c("date", "pcs")

# O plus
Oplus <- distr[distr$ABO == "O +", ]
Oplus.distr <- aggregate(Oplus$quantity, by = list(Oplus$date), sum); colnames(Oplus.distr) <- c("date", "pcs")

# A minus
Aminus <- distr[distr$ABO == "A -", ]
Aminus.distr <- aggregate(Aminus$quantity, by = list(Aminus$date), sum); colnames(Aminus.distr) <- c("date", "pcs")

# A plus
Aplus <- distr[distr$ABO == "A +", ]
Aplus.distr <- aggregate(Aplus$quantity, by = list(Aplus$date), sum); colnames(Aplus.distr) <- c("date", "pcs")

# B minus
Bminus <- distr[distr$ABO == "B -", ]
Bminus.distr <- aggregate(Bminus$quantity, by = list(Bminus$date), sum); colnames(Bminus.distr) <- c("date", "pcs")

# B plus
Bplus <- distr[distr$ABO == "B +", ]
Bplus.distr <- aggregate(Bplus$quantity, by = list(Bplus$date), sum); colnames(Bplus.distr) <- c("date", "pcs")

# AB minus
ABminus <- distr[distr$ABO == "AB-", ]
ABminus.distr <- aggregate(ABminus$quantity, by = list(ABminus$date), sum); colnames(ABminus.distr) <- c("date", "pcs")

# AB plus
ABplus <- distr[distr$ABO == "AB+", ]
ABplus.distr <- aggregate(ABplus$quantity, by = list(ABplus$date), sum); colnames(ABplus.distr) <- c("date", "pcs")
```

*Notes for development phase: 4% of the data is missing "ABO" and "volume" information. 4% is too much to be outright omitted, but now we have the problem where the smaller ABO series don't add up to "all.distr".*

```{r}
require(arsenal)
comparedf(all.distr, all.distr.other)
```


## Data goodness checks
```{r}
alldates <- (seq.Date(min(distr$date),
                       max(distr$date),
                       "day"))
typedates <- list(all.distr$date, Ominus.distr$date, Oplus.distr$date, 
                  Aminus.distr$date, Aplus.distr$date, Bminus.distr$date, 
                  Bplus.distr$date, ABminus.distr$date, ABplus.distr$date)
types <- list("All", "O-", "O+", "A-", "A+", "B-", "B+", "AB-", "AB+")
for(i in seq(9)){
  cat("Missing observations in ", types[[i]], ": ", length(alldates[!alldates %in% typedates[[i]]]), "\n")
}
```

Some blood types seem to have quite a lot of missing days. Let's look at the series more closely to get an estimate of the ratio between zeros and actual missing data.

```{r histograms, warning = FALSE}
ggplot(data = all.distr, aes(x = pcs)) + geom_histogram(binwidth = 1) + 
  labs(title = "All",
       subtitle = "Smallest value found: 2",
       caption = "", 
       x = "pcs", y = "count")

ggplot(data = Ominus.distr, aes(x = pcs)) + geom_histogram(binwidth = 1) + 
  labs(title = "O-",
       subtitle = "Missing days: 77",
       caption = "", 
       x = "pcs", y = "count")

ggplot(data = Oplus.distr, aes(x = pcs)) + geom_histogram(binwidth = 1) + 
  labs(title = "O+",
       subtitle = "Missing days: 33",
       caption = "", 
       x = "pcs", y = "count")

ggplot(data = Aminus.distr, aes(x = pcs)) + geom_histogram(binwidth = 1) + 
  labs(title = "A-",
       subtitle = "Missing days: 210",
       caption = "", 
       x = "pcs", y = "count")

ggplot(data = Aplus.distr, aes(x = pcs)) + geom_histogram(binwidth = 1) + 
  labs(title = "A+",
       subtitle = "Missing days: 37",
       caption = "", 
       x = "pcs", y = "count")

ggplot(data = Bminus.distr, aes(x = pcs)) + geom_histogram(binwidth = 1) + 
  labs(title = "B-",
       subtitle = "Missing days: 342",
       caption = "", 
       x = "pcs", y = "count")

ggplot(data = Bplus.distr, aes(x = pcs)) + geom_histogram(binwidth = 1) + 
  labs(title = "B+",
       subtitle = "Missing days: 161",
       caption = "", 
       x = "pcs", y = "count")

ggplot(data = ABminus.distr, aes(x = pcs)) + geom_histogram(binwidth = 1) + 
  labs(title = "AB-",
       subtitle = "Missing days: 538",
       caption = "", 
       x = "pcs", y = "count")

ggplot(data = ABplus.distr, aes(x = pcs)) + geom_histogram(binwidth = 1) + 
  labs(title = "AB+",
       subtitle = "Missing days: 350",
       caption = "", 
       x = "pcs", y = "count")
```

## First sanity check: does distribution data agree with sales data?
```{r monthly}
# Sum deliveries into monthly bins
distr.monthly <- aggregate(pcs ~ month(date) + year(date), data = all.distr, FUN = sum)
data <- data.frame(date = seq(from = as.Date("2014-01-01"), to = as.Date("2018-12-01"), by = "month"),
                   distr = distr.monthly[distr.monthly$`year(date)` >= 2014 & distr.monthly$`year(date)` <= 2018, ]$pcs,
                   sales = sales[sales$date >= "2014-01-01" & sales$date <= "2018-12-01", ]$Punasoluvalmisteet)
```


```{r plot}
# Plot
ggplot() + 
  geom_line(data = data, aes(x = date, y = distr, colour = "distribution"), size = 1) + 
  geom_point(data = data, aes(x = date, y = distr, colour = "distribution")) +
  geom_line(data = data, aes(x = date, y = sales, colour = "sales"), size = 1) + 
  geom_point(data = data, aes(x = date, y = sales, colour = "sales")) +
  scale_color_manual(values = c("#DF013A", "#298A08")) +
  theme(legend.position = "bottom", legend.margin = margin(t = -20, b = 20)) +
  labs(title = "Distribution vs. Sales",
       subtitle = "Distribution largely agrees with sales?",
       caption = "Note: Only red cell products here", 
       x = "", y = "blood bags") 
```

## Considering removals
Removals shouldn't make much of a difference, since removals contribute to under a percentage of the entirety of the data. To be thorough though, we should subtract removals from distributions and see if they then correspond better with the sales figures.

```{r removal_adj}
retrn.monthly <- aggregate(pcs ~ month(date) + year(date), data = all.retrn, FUN = sum)
distr.new <- distr.monthly[distr.monthly$`year(date)` >= 2014 & distr.monthly$`year(date)` <= 2018, ]$pcs
retrn.new <- retrn.monthly[retrn.monthly$`year(date)` >= 2014 & retrn.monthly$`year(date)` <= 2018, ]$pcs
tot <- distr.new - retrn.new
data.new <- data.frame(date = seq(from = as.Date("2014-01-01"), to = as.Date("2018-12-01"), by = "month"),
                       distr = distr.new,
                       retrn = retrn.new,
                       tot = tot,
                       sales = sales[sales$date >= "2014-01-01" & sales$date <= "2018-12-01", ]$Punasoluvalmisteet)
```

Plots
```{r removal_adj_plots}
ggplot() + 
  geom_line(data = data.new, aes(x = date, y = tot, colour = "distribution"), size = 1) + 
  geom_point(data = data.new, aes(x = date, y = tot, colour = "distribution")) +
  geom_line(data = data.new, aes(x = date, y = sales, colour = "sales"), size = 1) + 
  geom_point(data = data.new, aes(x = date, y = sales, colour = "sales")) +
  scale_color_manual(values = c("#DF013A", "#298A08")) +
  theme(legend.position = "bottom", legend.margin = margin(t = -20, b = 20)) +
  labs(title = "Distribution minus Returns vs. Sales",
       subtitle = "Distribution still largely corresponds to sales",
       caption = "Note: Might be that some returns have been invoiced regardless", 
       x = "", y = "blood bags")

```


```{r weekly}
# remember that this won't work if there are missing days
# cut to first monday
#conct.distr <- tail(all.distr, -5)

pcslist <- list()
weeklist <- list()
datelist <- list()
j <- 0
k <- 0
for(i in seq(to = length(all.distr$date), by = 7)){
  if(j == 52){j <- 0}
  j <- j + 1
  k <- k + 1
  pcslist[[k]] <- sum(all.distr$pcs[i : (i + 6)])
  weeklist[[k]] <- j
  datelist[[k]] <- all.distr$date[i]
}

distr.weekly <- data.frame(week = unlist(weeklist), 
                           startdate = as.Date.numeric(unlist(datelist), origin = "1970-01-01"), 
                           pcs = unlist(pcslist))
```


```{r}
ggplot(data = distr.weekly, aes(x = startdate, y = pcs)) + 
  geom_line() + 
  geom_smooth(data = distr.weekly[1:150,], aes(x = startdate, y = pcs), method = "lm", inherit.aes = FALSE) +
  geom_smooth(data = distr.weekly[151:287,], aes(x = startdate, y = pcs), method = "lm", inherit.aes = FALSE) +
  labs(title = "Weekly Distribution",
       subtitle = "Trend turns around 2017 and variance increases",
       x = "", y = "blood bags") +
  theme_bw()
```

```{r}
distr.weekly.mts <- msts(distr.weekly$pcs, start = decimal_date(as.Date("2014-01-06")), seasonal.periods = c(12, 52))
distr.weekly.mts <- window(distr.weekly.mts, start = 2017)
fit.weekly <- stlf(distr.weekly.mts)
autoplot(fit.weekly) +
  labs(title = "2 year forecast with data from 2017 onwards",
       subtitle = "Forecast appears much more certain about the shape of the seasons",
       x = "", y = "blood bags") +
  theme_bw()
```

The model clearly seems to have an idea about the pattern. Let's run a rolling partition test (a kind of CV) and average out the MAPEs to see what kind of errors we are talking about here.

## Weekly forecast
```{r weekly_forecast, warning = FALSE}
# Define the series to be used
distr.weekly.mts <- msts(distr.weekly$pcs, start = decimal_date(as.Date("2014-01-06")), seasonal.periods = c(12, 52))
distr.weekly.mts <- window(distr.weekly.mts, start = 2017)

es <- c()
apes <- c()
ses <- c()
capes <- c()

# Create progress bar
pb <- txtProgressBar(min = 1, max = length(distr.weekly.mts)-105, style = 3)

for(i in seq(length(distr.weekly.mts)-105)){
  # Define training and testing set as ROLLING WINDOW
  train <- msts(distr.weekly.mts[(1 + i):(104 + i)], start = decimal_date(as.Date("2014-01-06")), seasonal.periods = c(12, 52))
  test <- msts(distr.weekly.mts[(105 + i)], start = decimal_date(as.Date("2014-01-06")), seasonal.periods = c(12, 52))
  
  # Fit
  fit <- stlf(train)
  # Forecast 1 step (week) ahead
  fcast <- forecast(fit, h = 1)
  
  # Calculate errors
  e <- as.numeric(test) - as.numeric(fcast$mean)  # Raw error
  ape <- abs(100 * e/test)  # Absolute percentage error
  se <- e * e   # Squared error (for RMSE later on)
  cape <- ifelse(test = e > 0, yes = abs(e * 2), no = abs(e))/test * 100  # Critical APE (for cMAPE later on)
  
  # Save errors
  es <- c(es, e)
  apes <- c(apes, ape)
  ses <- c(ses, se)
  capes <- c(capes, cape)
  
  setTxtProgressBar(pb, i) # Update progress bar
}

close(pb) # Close progress bar

# Print errors for model selection
cat("

RESULTS
======================================
    Minimum error: ", min(abs(es)),
"
    Maximum error: ", max(es),
"
    MAPE: ", mean(apes),
"
    cMAPE: ", mean(capes),
"
    RMSE: ", sqrt(mean(ses)))
```

```{r}
# Define the series to be used
distr.weekly.mts <- msts(distr.weekly$pcs, start = decimal_date(as.Date("2014-01-06")), seasonal.periods = c(12, 52))
#distr.weekly.mts <- window(distr.weekly.mts, start = 2017)

############################
# TBATS
############################
fcasts <- c()
upper95 <- c()
upper80 <- c()
lower95 <- c()
lower80 <- c()
capes <- c()
# Create progress bar
cat("\nRUNNING TBATS\n")
pb <- txtProgressBar(min = 1, max = length(distr.weekly.mts) - 105, style = 3)
for(i in seq(length(distr.weekly.mts) - 105)){
  # Define training and testing set as ROLLING WINDOW
  train <- msts(distr.weekly.mts[(1 + i):(104 + i)], start = decimal_date(as.Date("2014-01-06") + i + 1), seasonal.periods = c(12, 52))
  test <- msts(distr.weekly.mts[(105 + i)], start = decimal_date(as.Date("2014-01-06") + 105 + i), seasonal.periods = c(12, 52))
  # Fit
  fit <- stlf(train)
  # Forecast 1 step (week) ahead
  fcast <- forecast(fit, h = 1)
  
  # Save data for plotting
  fcasts <- c(fcasts, as.numeric(fcast$mean))
  upper95 <- c(upper95, fcast$upper[2])
  upper80 <- c(upper80, fcast$upper[1])
  lower95 <- c(lower95, fcast$lower[2])
  lower80 <- c(lower80, fcast$lower[1])
  
  
  # Calculate errors
  e <- as.numeric(test) - as.numeric(fcast$mean)  # Raw error
  cape <- ifelse(test = e > 0, yes = abs(e * 2), no = abs(e))/test * 100  # Critical APE (for cMAPE later on)
  
  # Save errors
  capes <- c(capes, cape)
  
  setTxtProgressBar(pb, i) # Update progress bar
}
close(pb) # Close progress bar

tbats.capes <- capes
```

```{r}
plot.data <- data.frame(date = seq(from = as.Date("2016-01-18"), 
                                   to = as.Date("2019-07-15")-1, 
                                   by = "week"),
                        real = distr.weekly.mts[106:287],
                        fcast = fcasts,
                        upper95 = upper95,
                        upper80 = upper80,
                        lower95 = lower95,
                        lower80 = lower80)

ggplot(data = plot.data, aes(x = date, y = fcast)) +
  geom_line(data = plot.data, aes(x = date, y = real), color = "black") +
  geom_line(color = "blue") +
  geom_ribbon(data = plot.data, aes(ymin = lower80, ymax = upper80), alpha = 0.3) +
  geom_ribbon(data = plot.data, aes(ymin = lower95, ymax = upper95), alpha = 0.2, fill = "blue")
```

```{r model_selection, warning=FALSE, echo=FALSE}
# Define the series to be used
distr.weekly.mts <- msts(distr.weekly$pcs, start = decimal_date(as.Date("2014-01-06")), seasonal.periods = c(12, 52))
#distr.weekly.mts <- window(distr.weekly.mts, start = 2017)

############################
# TBATS
############################
plot.tbats <- ggplot()
capes <- c()
# Create progress bar
cat("\nRUNNING TBATS\n")
pb <- txtProgressBar(min = 1, max = length(distr.weekly.mts) - 105, style = 3)
for(i in seq(length(distr.weekly.mts) - 105)){
  # Define training and testing set as ROLLING WINDOW
  train <- msts(distr.weekly.mts[(1 + i):(104 + i)], start = decimal_date(as.Date("2014-01-06") + i), seasonal.periods = c(12, 52))
  test <- msts(distr.weekly.mts[(105 + i)], start = decimal_date(as.Date("2014-01-06") + 105 + i), seasonal.periods = c(12, 52))
  # Fit
  fit <- tbats(train)
  # Forecast 1 step (week) ahead
  fcast <- forecast(fit, h = 1)
  
  # Build the plot piece by piece
  plot.tbats <- plot.tbats + autolayer(fcast) + autolayer(test, colour=FALSE)
  
  
  # Calculate errors
  e <- as.numeric(test) - as.numeric(fcast$mean)  # Raw error
  cape <- ifelse(test = e > 0, yes = abs(e * 2), no = abs(e))/test * 100  # Critical APE (for cMAPE later on)
  
  # Save errors
  capes <- c(capes, cape)
  
  setTxtProgressBar(pb, i) # Update progress bar
}
close(pb) # Close progress bar

tbats.capes <- capes

############################
# STLF
############################
capes <- c()
# Create progress bar
cat("\nRUNNING STLF\n")
pb <- txtProgressBar(min = 1, max = length(distr.weekly.mts) - 105, style = 3)
for(i in seq(length(distr.weekly.mts) - 105)){
  # Define training and testing set as ROLLING WINDOW
  train <- msts(distr.weekly.mts[(1 + i):(104 + i)], start = decimal_date(as.Date("2014-01-06")), seasonal.periods = c(12, 52))
  test <- msts(distr.weekly.mts[(105 + i)], start = decimal_date(as.Date("2014-01-06")), seasonal.periods = c(12, 52))
  
  # Fit
  fit <- stlf(train)
  # Forecast 1 step (week) ahead
  fcast <- forecast(fit, h = 1)
  
  # Calculate errors
  e <- as.numeric(test) - as.numeric(fcast$mean)  # Raw error
  cape <- ifelse(test = e > 0, yes = abs(e * 2), no = abs(e))/test * 100  # Critical APE (for cMAPE later on)
  
  # Save errors
  capes <- c(capes, cape)
  
  setTxtProgressBar(pb, i) # Update progress bar
}
close(pb) # Close progress bar

stlf.capes <- capes

############################
# LMx2
############################
capes <- c()
cat("\nRUNNING LMx2\n")
# Create progress bar
pb <- txtProgressBar(min = 1, max = length(distr.weekly.mts) - 105, style = 3)
for(i in seq(length(distr.weekly.mts) - 105)){
  # Define training and testing set as ROLLING WINDOW
  train <- msts(distr.weekly.mts[(1 + i):(104 + i)], start = decimal_date(as.Date("2014-01-06")), seasonal.periods = c(12, 52))
  test <- msts(distr.weekly.mts[(105 + i)], start = decimal_date(as.Date("2014-01-06")), seasonal.periods = c(12, 52))
  
  # Fit & Forecast
  fit1 <- tslm(train ~ trend + season)
  fcast1 <- forecast(fit1, h = 1)
 
  fit2 <- auto.arima(fit1$residuals)
  fcast2 <- forecast(fit2, h = 1)
  
  y <- as.numeric(fcast1$mean)
  x <- as.numeric(fcast2$mean)
  fcast <- x + y
  
  # Calculate errors
  e <- as.numeric(test) - as.numeric(fcast)  # Raw error
  cape <- ifelse(test = e > 0, yes = abs(e * 2), no = abs(e))/test * 100  # Critical APE (for cMAPE later on)
  
  # Save errors
  capes <- c(capes, cape)
  
  setTxtProgressBar(pb, i) # Update progress bar
}
close(pb) # Close progress bar

lmx2.capes <- capes

############################
# NAIVE
############################
capes <- c()
cat("\nRUNNING NAIVE\n")
# Create progress bar
pb <- txtProgressBar(min = 1, max = length(distr.weekly.mts) - 105, style = 3)
for(i in seq(length(distr.weekly.mts) - 105)){
  # Define training and testing set as ROLLING WINDOW
  train <- msts(distr.weekly.mts[(1 + i):(104 + i)], start = decimal_date(as.Date("2014-01-06")), seasonal.periods = c(12, 52))
  test <- msts(distr.weekly.mts[(105 + i)], start = decimal_date(as.Date("2014-01-06")), seasonal.periods = c(12, 52))

  # Fit
  fit <- naive(train)
  # Forecast 1 step (week) ahead
  fcast <- forecast(fit, h = 1)
  
  # Calculate errors
  e <- as.numeric(test) - as.numeric(fcast$mean)  # Raw error
  cape <- ifelse(test = e > 0, yes = abs(e * 2), no = abs(e))/test * 100  # Critical APE (for cMAPE later on)
  
  # Save errors
  capes <- c(capes, cape)
  
  setTxtProgressBar(pb, i) # Update progress bar
}
close(pb) # Close progress bar

naive.capes <- capes

############################
# SNAIVE
############################
capes <- c()
cat("\nRUNNING SNAIVE\n")
# Create progress bar
pb <- txtProgressBar(min = 1, max = length(distr.weekly.mts) - 105, style = 3)
for(i in seq(length(distr.weekly.mts) - 105)){
  # Define training and testing set as ROLLING WINDOW
  train <- msts(distr.weekly.mts[(1 + i):(104 + i)], start = decimal_date(as.Date("2014-01-06")), seasonal.periods = c(12, 52))
  test <- msts(distr.weekly.mts[(105 + i)], start = decimal_date(as.Date("2014-01-06")), seasonal.periods = c(12, 52))

  # Fit
  fit <- snaive(train)
  # Forecast 1 step (week) ahead
  fcast <- forecast(fit, h = 1)
  
  # Calculate errors
  e <- as.numeric(test) - as.numeric(fcast$mean)  # Raw error
  cape <- ifelse(test = e > 0, yes = abs(e * 2), no = abs(e))/test * 100  # Critical APE (for cMAPE later on)
  
  # Save errors
  capes <- c(capes, cape)
  
  setTxtProgressBar(pb, i) # Update progress bar
}
close(pb) # Close progress bar

snaive.capes <- capes

############################
# RWF
############################
capes <- c()
cat("\nRUNNING RWF\n")
# Create progress bar
pb <- txtProgressBar(min = 1, max = length(distr.weekly.mts) - 105, style = 3)
for(i in seq(length(distr.weekly.mts) - 105)){
  # Define training and testing set as ROLLING WINDOW
  train <- msts(distr.weekly.mts[(1 + i):(104 + i)], start = decimal_date(as.Date("2014-01-06")), seasonal.periods = c(12, 52))
  test <- msts(distr.weekly.mts[(105 + i)], start = decimal_date(as.Date("2014-01-06")), seasonal.periods = c(12, 52))

  # Fit
  fit <- rwf(train, drift = TRUE)
  # Forecast 1 step (week) ahead
  fcast <- forecast(fit, h = 1)
  
  # Calculate errors
  e <- as.numeric(test) - as.numeric(fcast$mean)  # Raw error
  cape <- ifelse(test = e > 0, yes = abs(e * 2), no = abs(e))/test * 100  # Critical APE (for cMAPE later on)
  
  # Save errors
  capes <- c(capes, cape)
  
  setTxtProgressBar(pb, i) # Update progress bar
}
close(pb) # Close progress bar

rwf.capes <- capes

############################
# MEANF
############################
capes <- c()
cat("\nRUNNING MEANF\n")
# Create progress bar
pb <- txtProgressBar(min = 1, max = length(distr.weekly.mts) - 105, style = 3)
for(i in seq(length(distr.weekly.mts) - 105)){
  # Define training and testing set as ROLLING WINDOW
  train <- msts(distr.weekly.mts[(1 + i):(104 + i)], start = decimal_date(as.Date("2014-01-06")), seasonal.periods = c(12, 52))
  test <- msts(distr.weekly.mts[(105 + i)], start = decimal_date(as.Date("2014-01-06")), seasonal.periods = c(12, 52))

  # Fit
  fit <- meanf(train)
  # Forecast 1 step (week) ahead
  fcast <- forecast(fit, h = 1)
  
  # Calculate errors
  e <- as.numeric(test) - as.numeric(fcast$mean)  # Raw error
  cape <- ifelse(test = e > 0, yes = abs(e * 2), no = abs(e))/test * 100  # Critical APE (for cMAPE later on)
  
  # Save errors
  capes <- c(capes, cape)
  
  setTxtProgressBar(pb, i) # Update progress bar
}
close(pb) # Close progress bar

meanf.capes <- capes

############################
# Smooth .25 TBATS
############################
capes <- c()
cat("\nRUNNING SMOOTH TBATS\n")
# Create progress bar
pb <- txtProgressBar(min = 1, max = length(distr.weekly.mts) - 105, style = 3)
for(i in seq(length(distr.weekly.mts) - 105)){
  # Define training and testing set as ROLLING WINDOW
  train <- msts(itsmr::smooth.fft(distr.weekly.mts[(1 + i):(104 + i)], .25), 
                start = decimal_date(as.Date("2014-01-06")), 
                seasonal.periods = c(12, 52))
  test <- msts(distr.weekly.mts[(105 + i)], start = decimal_date(as.Date("2014-01-06")), seasonal.periods = c(12, 52))

  # Fit
  fit <- tbats(train)
  # Forecast 1 step (week) ahead
  fcast <- forecast(fit, h = 1)
  
  # Calculate errors
  e <- as.numeric(test) - as.numeric(fcast$mean)  # Raw error
  cape <- ifelse(test = e > 0, yes = abs(e * 2), no = abs(e))/test * 100  # Critical APE (for cMAPE later on)
  
  # Save errors
  capes <- c(capes, cape)
  
  setTxtProgressBar(pb, i) # Update progress bar
}
close(pb) # Close progress bar

smthtbats.capes <- capes

############################
# Smooth .25 STLF
############################
capes <- c()
cat("\nRUNNING SMOOTH STLF\n")
# Create progress bar
pb <- txtProgressBar(min = 1, max = length(distr.weekly.mts) - 105, style = 3)
for(i in seq(length(distr.weekly.mts) - 105)){
  # Define training and testing set as ROLLING WINDOW
  train <- msts(itsmr::smooth.fft(distr.weekly.mts[(1 + i):(104 + i)], .25), 
                start = decimal_date(as.Date("2014-01-06")), 
                seasonal.periods = c(12, 52))
  test <- msts(distr.weekly.mts[(105 + i)], start = decimal_date(as.Date("2014-01-06")), seasonal.periods = c(12, 52))

  # Fit
  fit <- stlf(train)
  # Forecast 1 step (week) ahead
  fcast <- forecast(fit, h = 1)
  
  # Calculate errors
  e <- as.numeric(test) - as.numeric(fcast$mean)  # Raw error
  cape <- ifelse(test = e > 0, yes = abs(e * 2), no = abs(e))/test * 100  # Critical APE (for cMAPE later on)
  
  # Save errors
  capes <- c(capes, cape)
  
  setTxtProgressBar(pb, i) # Update progress bar
}
close(pb) # Close progress bar

smthstlf.capes <- capes

############################
# Smooth .25 LMx2
############################
capes <- c()
cat("\nRUNNING SMOOTH LMx2\n")
# Create progress bar
pb <- txtProgressBar(min = 1, max = length(distr.weekly.mts) - 105, style = 3)
for(i in seq(length(distr.weekly.mts) - 105)){
  # Define training and testing set as ROLLING WINDOW
  train <- msts(itsmr::smooth.fft(distr.weekly.mts[(1 + i):(104 + i)], .25), 
                start = decimal_date(as.Date("2014-01-06")), 
                seasonal.periods = c(12, 52))
  test <- msts(distr.weekly.mts[(105 + i)], start = decimal_date(as.Date("2014-01-06")), seasonal.periods = c(12, 52))

  # Fit & Forecast
  fit1 <- tslm(train ~ trend + season)
  fcast1 <- forecast(fit1, h = 1)
 
  fit2 <- auto.arima(fit1$residuals)
  fcast2 <- forecast(fit2, h = 1)
  
  y <- as.numeric(fcast1$mean)
  x <- as.numeric(fcast2$mean)
  fcast <- x + y
  
  # Calculate errors
  e <- as.numeric(test) - as.numeric(fcast)  # Raw error
  cape <- ifelse(test = e > 0, yes = abs(e * 2), no = abs(e))/test * 100  # Critical APE (for cMAPE later on)
  
  # Save errors
  capes <- c(capes, cape)
  
  setTxtProgressBar(pb, i) # Update progress bar
}
close(pb) # Close progress bar

smthlmx2.capes <- capes

############################
# Smooth .25 NAIVE
############################
capes <- c()
cat("\nRUNNING SMOOTH NAIVE\n")
# Create progress bar
pb <- txtProgressBar(min = 1, max = length(distr.weekly.mts) - 105, style = 3)
for(i in seq(length(distr.weekly.mts) - 105)){
  # Define training and testing set as ROLLING WINDOW
  train <- msts(itsmr::smooth.fft(distr.weekly.mts[(1 + i):(104 + i)], .25), 
                start = decimal_date(as.Date("2014-01-06")), 
                seasonal.periods = c(12, 52))
  test <- msts(distr.weekly.mts[(105 + i)], start = decimal_date(as.Date("2014-01-06")), seasonal.periods = c(12, 52))
  
  # Fit
  fit <- naive(train)
  # Forecast 1 step (week) ahead
  fcast <- forecast(fit, h = 1)
  
  # Calculate errors
  e <- as.numeric(test) - as.numeric(fcast$mean)  # Raw error
  cape <- ifelse(test = e > 0, yes = abs(e * 2), no = abs(e))/test * 100  # Critical APE (for cMAPE later on)
  
  # Save errors
  capes <- c(capes, cape)
  
  setTxtProgressBar(pb, i) # Update progress bar
}
close(pb) # Close progress bar

smthnaive.capes <- capes

############################
# Smooth .25 SNAIVE
############################
capes <- c()
cat("\nRUNNING SMOOTH SNAIVE\n")
# Create progress bar
pb <- txtProgressBar(min = 1, max = length(distr.weekly.mts) - 105, style = 3)
for(i in seq(length(distr.weekly.mts) - 105)){
  # Define training and testing set as ROLLING WINDOW
  train <- msts(itsmr::smooth.fft(distr.weekly.mts[(1 + i):(104 + i)], .25), 
                start = decimal_date(as.Date("2014-01-06")), 
                seasonal.periods = c(12, 52))
  test <- msts(distr.weekly.mts[(105 + i)], start = decimal_date(as.Date("2014-01-06")), seasonal.periods = c(12, 52))

  # Fit
  fit <- snaive(train)
  # Forecast 1 step (week) ahead
  fcast <- forecast(fit, h = 1)
  
  # Calculate errors
  e <- as.numeric(test) - as.numeric(fcast$mean)  # Raw error
  cape <- ifelse(test = e > 0, yes = abs(e * 2), no = abs(e))/test * 100  # Critical APE (for cMAPE later on)
  
  # Save errors
  capes <- c(capes, cape)
  
  setTxtProgressBar(pb, i) # Update progress bar
}
close(pb) # Close progress bar

smthsnaive.capes <- capes

############################
# Smooth .25 RWF
############################
capes <- c()
cat("\nRUNNING SMOOTH RWF\n")
# Create progress bar
pb <- txtProgressBar(min = 1, max = length(distr.weekly.mts) - 105, style = 3)
for(i in seq(length(distr.weekly.mts) - 105)){
  # Define training and testing set as ROLLING WINDOW
  train <- msts(itsmr::smooth.fft(distr.weekly.mts[(1 + i):(104 + i)], .25), 
                start = decimal_date(as.Date("2014-01-06")), 
                seasonal.periods = c(12, 52))
  test <- msts(distr.weekly.mts[(105 + i)], start = decimal_date(as.Date("2014-01-06")), seasonal.periods = c(12, 52))

  # Fit
  fit <- rwf(train, drift = TRUE)
  # Forecast 1 step (week) ahead
  fcast <- forecast(fit, h = 1)
  
  # Calculate errors
  e <- as.numeric(test) - as.numeric(fcast$mean)  # Raw error
  cape <- ifelse(test = e > 0, yes = abs(e * 2), no = abs(e))/test * 100  # Critical APE (for cMAPE later on)
  
  # Save errors
  capes <- c(capes, cape)
  
  setTxtProgressBar(pb, i) # Update progress bar
}
close(pb) # Close progress bar

smthrwf.capes <- capes

############################
# Smooth .25 MEANF
############################
capes <- c()
cat("\nRUNNING SMOOTH MEANF\n")
# Create progress bar
pb <- txtProgressBar(min = 1, max = length(distr.weekly.mts) - 105, style = 3)
for(i in seq(length(distr.weekly.mts) - 105)){
  # Define training and testing set as ROLLING WINDOW
  train <- msts(itsmr::smooth.fft(distr.weekly.mts[(1 + i):(104 + i)], .25), 
                start = decimal_date(as.Date("2014-01-06")), 
                seasonal.periods = c(12, 52))
  test <- msts(distr.weekly.mts[(105 + i)], start = decimal_date(as.Date("2014-01-06")), seasonal.periods = c(12, 52))

  # Fit
  fit <- meanf(train)
  # Forecast 1 step (week) ahead
  fcast <- forecast(fit, h = 1)
  
  # Calculate errors
  e <- as.numeric(test) - as.numeric(fcast$mean)  # Raw error
  cape <- ifelse(test = e > 0, yes = abs(e * 2), no = abs(e))/test * 100  # Critical APE (for cMAPE later on)
  
  # Save errors
  capes <- c(capes, cape)
  
  setTxtProgressBar(pb, i) # Update progress bar
}
close(pb) # Close progress bar

smthmeanf.capes <- capes

############################
# Smooth .10 TBATS
############################
capes <- c()
cat("\nRUNNING SMOOTH .10 TBATS\n")
# Create progress bar
pb <- txtProgressBar(min = 1, max = length(distr.weekly.mts) - 105, style = 3)
for(i in seq(length(distr.weekly.mts) - 105)){
  # Define training and testing set as ROLLING WINDOW
  train <- msts(itsmr::smooth.fft(distr.weekly.mts[(1 + i):(104 + i)], .10), 
                start = decimal_date(as.Date("2014-01-06")), 
                seasonal.periods = c(12, 52))
  test <- msts(distr.weekly.mts[(105 + i)], start = decimal_date(as.Date("2014-01-06")), seasonal.periods = c(12, 52))

  # Fit
  fit <- tbats(train)
  # Forecast 1 step (week) ahead
  fcast <- forecast(fit, h = 1)
  
  # Calculate errors
  e <- as.numeric(test) - as.numeric(fcast$mean)  # Raw error
  cape <- ifelse(test = e > 0, yes = abs(e * 2), no = abs(e))/test * 100  # Critical APE (for cMAPE later on)
  
  # Save errors
  capes <- c(capes, cape)
  
  setTxtProgressBar(pb, i) # Update progress bar
}
close(pb) # Close progress bar

smth10tbats.capes <- capes

############################
# Smooth .10 STLF
############################
capes <- c()
cat("\nRUNNING SMOOTH .10 STLF\n")
# Create progress bar
pb <- txtProgressBar(min = 1, max = length(distr.weekly.mts) - 105, style = 3)
for(i in seq(length(distr.weekly.mts) - 105)){
  # Define training and testing set as ROLLING WINDOW
  train <- msts(itsmr::smooth.fft(distr.weekly.mts[(1 + i):(104 + i)], .10), 
                start = decimal_date(as.Date("2014-01-06")), 
                seasonal.periods = c(12, 52))
  test <- msts(distr.weekly.mts[(105 + i)], start = decimal_date(as.Date("2014-01-06")), seasonal.periods = c(12, 52))

  # Fit
  fit <- stlf(train)
  # Forecast 1 step (week) ahead
  fcast <- forecast(fit, h = 1)
  
  # Calculate errors
  e <- as.numeric(test) - as.numeric(fcast$mean)  # Raw error
  cape <- ifelse(test = e > 0, yes = abs(e * 2), no = abs(e))/test * 100  # Critical APE (for cMAPE later on)
  
  # Save errors
  capes <- c(capes, cape)
  
  setTxtProgressBar(pb, i) # Update progress bar
}
close(pb) # Close progress bar

smth10stlf.capes <- capes

############################
# Smooth .10 LMx2
############################
capes <- c()
cat("\nRUNNING SMOOTH .10 LMx2\n")
# Create progress bar
pb <- txtProgressBar(min = 1, max = length(distr.weekly.mts) - 105, style = 3)
for(i in seq(length(distr.weekly.mts) - 105)){
  # Define training and testing set as ROLLING WINDOW
  train <- msts(itsmr::smooth.fft(distr.weekly.mts[(1 + i):(104 + i)], .10), 
                start = decimal_date(as.Date("2014-01-06")), 
                seasonal.periods = c(12, 52))
  test <- msts(distr.weekly.mts[(105 + i)], start = decimal_date(as.Date("2014-01-06")), seasonal.periods = c(12, 52))

  # Fit & Forecast
  fit1 <- tslm(train ~ trend + season)
  fcast1 <- forecast(fit1, h = 1)
 
  fit2 <- auto.arima(fit1$residuals)
  fcast2 <- forecast(fit2, h = 1)
  
  y <- as.numeric(fcast1$mean)
  x <- as.numeric(fcast2$mean)
  fcast <- x + y
  
  # Calculate errors
  e <- as.numeric(test) - as.numeric(fcast)  # Raw error
  cape <- ifelse(test = e > 0, yes = abs(e * 2), no = abs(e))/test * 100  # Critical APE (for cMAPE later on)
  
  # Save errors
  capes <- c(capes, cape)
  
  setTxtProgressBar(pb, i) # Update progress bar
}
close(pb) # Close progress bar

smth10lmx2.capes <- capes

############################
# Smooth .10 NAIVE
############################
capes <- c()
cat("\nRUNNING SMOOTH .10 NAIVE\n")
# Create progress bar
pb <- txtProgressBar(min = 1, max = length(distr.weekly.mts) - 105, style = 3)
for(i in seq(length(distr.weekly.mts) - 105)){
  # Define training and testing set as ROLLING WINDOW
  train <- msts(itsmr::smooth.fft(distr.weekly.mts[(1 + i):(104 + i)], .10), 
                start = decimal_date(as.Date("2014-01-06")), 
                seasonal.periods = c(12, 52))
  test <- msts(distr.weekly.mts[(105 + i)], start = decimal_date(as.Date("2014-01-06")), seasonal.periods = c(12, 52))
  
  # Fit
  fit <- naive(train)
  # Forecast 1 step (week) ahead
  fcast <- forecast(fit, h = 1)
  
  # Calculate errors
  e <- as.numeric(test) - as.numeric(fcast$mean)  # Raw error
  cape <- ifelse(test = e > 0, yes = abs(e * 2), no = abs(e))/test * 100  # Critical APE (for cMAPE later on)
  
  # Save errors
  capes <- c(capes, cape)
  
  setTxtProgressBar(pb, i) # Update progress bar
}
close(pb) # Close progress bar

smth10naive.capes <- capes

############################
# Smooth .10 SNAIVE
############################
capes <- c()
cat("\nRUNNING SMOOTH .10 SNAIVE\n")
# Create progress bar
pb <- txtProgressBar(min = 1, max = length(distr.weekly.mts) - 105, style = 3)
for(i in seq(length(distr.weekly.mts) - 105)){
  # Define training and testing set as ROLLING WINDOW
  train <- msts(itsmr::smooth.fft(distr.weekly.mts[(1 + i):(104 + i)], .10), 
                start = decimal_date(as.Date("2014-01-06")), 
                seasonal.periods = c(12, 52))
  test <- msts(distr.weekly.mts[(105 + i)], start = decimal_date(as.Date("2014-01-06")), seasonal.periods = c(12, 52))

  # Fit
  fit <- snaive(train)
  # Forecast 1 step (week) ahead
  fcast <- forecast(fit, h = 1)
  
  # Calculate errors
  e <- as.numeric(test) - as.numeric(fcast$mean)  # Raw error
  cape <- ifelse(test = e > 0, yes = abs(e * 2), no = abs(e))/test * 100  # Critical APE (for cMAPE later on)
  
  # Save errors
  capes <- c(capes, cape)
  
  setTxtProgressBar(pb, i) # Update progress bar
}
close(pb) # Close progress bar

smth10snaive.capes <- capes

############################
# Smooth .10 RWF
############################
capes <- c()
cat("\nRUNNING SMOOTH .10 RWF\n")
# Create progress bar
pb <- txtProgressBar(min = 1, max = length(distr.weekly.mts) - 105, style = 3)
for(i in seq(length(distr.weekly.mts) - 105)){
  # Define training and testing set as ROLLING WINDOW
  train <- msts(itsmr::smooth.fft(distr.weekly.mts[(1 + i):(104 + i)], .10), 
                start = decimal_date(as.Date("2014-01-06")), 
                seasonal.periods = c(12, 52))
  test <- msts(distr.weekly.mts[(105 + i)], start = decimal_date(as.Date("2014-01-06")), seasonal.periods = c(12, 52))

  # Fit
  fit <- rwf(train, drift = TRUE)
  # Forecast 1 step (week) ahead
  fcast <- forecast(fit, h = 1)
  
  # Calculate errors
  e <- as.numeric(test) - as.numeric(fcast$mean)  # Raw error
  cape <- ifelse(test = e > 0, yes = abs(e * 2), no = abs(e))/test * 100  # Critical APE (for cMAPE later on)
  
  # Save errors
  capes <- c(capes, cape)
  
  setTxtProgressBar(pb, i) # Update progress bar
}
close(pb) # Close progress bar

smth10rwf.capes <- capes

############################
# Smooth .10 MEANF
############################
capes <- c()
cat("\nRUNNING SMOOTH .10 MEANF\n")
# Create progress bar
pb <- txtProgressBar(min = 1, max = length(distr.weekly.mts) - 105, style = 3)
for(i in seq(length(distr.weekly.mts) - 105)){
  # Define training and testing set as ROLLING WINDOW
  train <- msts(itsmr::smooth.fft(distr.weekly.mts[(1 + i):(104 + i)], .10), 
                start = decimal_date(as.Date("2014-01-06")), 
                seasonal.periods = c(12, 52))
  test <- msts(distr.weekly.mts[(105 + i)], start = decimal_date(as.Date("2014-01-06")), seasonal.periods = c(12, 52))

  # Fit
  fit <- meanf(train)
  # Forecast 1 step (week) ahead
  fcast <- forecast(fit, h = 1)
  
  # Calculate errors
  e <- as.numeric(test) - as.numeric(fcast$mean)  # Raw error
  cape <- ifelse(test = e > 0, yes = abs(e * 2), no = abs(e))/test * 100  # Critical APE (for cMAPE later on)
  
  # Save errors
  capes <- c(capes, cape)
  
  setTxtProgressBar(pb, i) # Update progress bar
}
close(pb) # Close progress bar

smth10meanf.capes <- capes
```

```{r}
m <- matrix(c(tbats.capes, stlf.capes, lmx2.capes, naive.capes, snaive.capes, rwf.capes, meanf.capes,
              smthtbats.capes, smthstlf.capes, smthlmx2.capes, smthnaive.capes, smthsnaive.capes, smthrwf.capes, smthmeanf.capes,
              smth10tbats.capes, smth10stlf.capes, smth10lmx2.capes, smth10naive.capes, smth10snaive.capes, smth10rwf.capes,
              smth10meanf.capes),
            ncol = 21,
            byrow = FALSE)
colnames(m) <- c("TBATS", "STLF", "LMx2", "NAIVE", "SNAIVE", "RWF", "MEANF",
                 "TBATS .25", "STLF .25", "LMx2 .25", "NAIVE .25", "SNAIVE .25", "RWF .25", "MEANF .25",
                 "TBATS .10", "STLF .10", "LMx2 .10", "NAIVE .10", "SNAIVE .10", "RWF .10", "MEANF .10")

kable(m, "markdown")
```

## Explore errors
```{r}
mdf <- as.data.frame(m)
ggplot() + 
  geom_line(data = mdf, aes(x = seq(182), y = SNAIVE), color = "red") +
  #geom_line(data = mdf, aes(x = seq(182), y = TBATS), color = "blue") +
  geom_line(data = mdf, aes(x = seq(182), y = RWF), color = "green") +
  geom_line(data = mdf, aes(x = seq(182), y = LMx2), color = "blue")
```

## Gamed version
```{r}
# Use TBATS except if RWF[i-9] > 28 && < 40
minerr <- c()
for(i in seq(to = length(m[, 1])-1)){
  if(i > 50){
    if(m[(i-8), 6] > 28){
      minerr <- c(minerr, m[i+1, 2])
    }
    else{
      minerr <- c(minerr, m[i+1, 1])
    }
  }
  else{
    minerr <- c(minerr, m[i+1, 1])
  }
}
mean(minerr)
```


## Best scenario
```{r}
minerrors <- c()
for(i in seq(to = length(m[, 1]))){
  minerrors <- c(minerrors, min(m[i, ]))
}
mean(minerrors)
```


## Model selection history
```{r}
errors <- c()
for(i in seq(to = length(m[,1]) - 53)){
  name <- names(which.min(colMeans(m[i:(i+52), ])))
  colnum <- which.min(colMeans(m[i:(i+52), ]))[[1]]
  e <- m[(i+53), colnum]
  if(i >= 53){
    if(e > min(m[(i-52), ])){
    name <- names(which.min(m[(i-52), ]))
    colnum <- which.min(m[(i-52), ])[[1]]
    errors <- c(errors, m[(i+53), colnum])
  }
  else{
    errors <- c(errors, e)
  }
  }
  
  
  cat("\n
Best model on 2 year rolling window:", name,
      "
Next week's forecast error: ", m[(i+53), colnum])
}

```


```{r}
errors <- c()
for(i in seq(to = length(m[,1]) - 53)){
  name <- names(which.min(colMeans(m[i:(i+52), ])))
  colnum <- which.min(colMeans(m[i:(i+52), ]))[[1]]
  e <- m[(i+53), colnum]
  if(e > min(colMeans(m[1:(i+52),]))){
    name <- names(which.min(colMeans(m[1:(i+52), ])))
    colnum <- which.min(colMeans(m[1:(i+52), ]))[[1]]
    errors <- c(errors, m[(i+53), colnum])
  }
  else{
    errors <- c(errors, e)
  }
  
  cat("\n
Best model on 2 year rolling window:", name,
      "
Next week's forecast error: ", m[(i+53), colnum])
}

```

## Model selection performance if new shape persists
```{r}
weeks <- c()
k <- 27
for(j in seq(104)){
  if(k == 52){k <- 0}
  k <- k + 1
  weeks <- c(weeks, k)
}
newdata <- data.frame(week = weeks,
                      startdate = seq(from = as.Date("2019-07-08"), to = as.Date("2021-06-28"), by = "week"),
                      pcs = fit.weekly$mean)
fake.weekly <- rbind(distr.weekly, newdata)

ggplot(data = fake.weekly, aes(x = startdate, y = pcs)) + 
  geom_line()
```

