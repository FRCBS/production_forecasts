---
title: "Production Forecasts"
output: html_document
---
```{r setup, echo = FALSE}
# Set working directory
knitr::opts_knit$set(root.dir = "/home/esa/production_forecasts") # Working on Ubuntu

# Colorblind palette
# black, orange, sky blue, green,
# yellow, blue, vermilion, purple
cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", 
                "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

# To use for fills, add
# scale_fill_manual(values=cbbPalette)

# To use for line and point colors, add
# scale_colour_manual(values=cbbPalette)
```

```{r imports, message = FALSE, echo = FALSE}
library(forecast)
library(ggplot2)
library(gridExtra)
library(knitr)
library(plyr)
library(lubridate)
library(numbers)
library(data.table)
library(R.utils)
library(DT)
source("src/pffunctions.R")
```

```{r read_files, include = FALSE}
# Get all the files
PATH <- "/home/esa/production_forecasts/data/FACS/"
files <- list.files(path = PATH, pattern = "FAC0091_*")  # Character vector of file names

# Compile a dataframe by going over all files
dlist <- list()
for (i in files) {
  # Read a single file to a df called d
  d <- read.delim(file = paste0(PATH, "/", i), header = FALSE, sep = ";", stringsAsFactors = FALSE, colClasses = 'character')
  
  if(length(d) == 26){
    d <- d[, !(names(d) %in% c("V10"))]  # The column numbers unfortunately vary between files, so we'll adjust
    }
  
  colnames(d) <- c("V1", "V2", "V3", "V4", "V5", "V6", "V7", "V8", "V9", "V10",
                   "V11", "V12", "V13", "V14", "V15", "V16", "V17", "V18", "V19", "V20",
                   "V21", "V22", "V23", "V24", "V25")  # This is done so as to have easier column handling later on
  dlist[[i]] <- d
}

d <- as.data.frame(rbindlist(dlist, fill = TRUE))
```

```{r modify_dataframe, include = FALSE}
# Divide into distributions (P) and returns (R)
P <- d[d$V1 == "P", ]
R <- d[d$V1 == "R", ]

# For distributions, we'll keep Distribution date, Quantity, ABO type, Volume, Exp date
keep <- c("V12", "V14", "V18", "V20", "V22", "V24")
distr <- P[keep]
colnames(distr) <- c("date", "product", "quantity", "ABO", "volume", "exp")

# For returns we keep the return date and quantity
keep <- c("V4", "V7")
retrn <- R[keep]
colnames(retrn) <- c("date", "quantity")

# Datify
distr$date <- dmy(distr$date); distr$exp <- dmy(distr$exp)
retrn$date <- dmy(retrn$date)

# Numerify
distr$quantity <- as.numeric(distr$quantity); distr$volume <- as.numeric(distr$volume)
retrn$quantity <- as.numeric(retrn$quantity)

# Product codes for red cell products
red.codes <- c("budTR001", "A0071V00", "A0074V00", "A0092VA0", "A0092VB0", 
               "E3844V00", "E3845V00", "E3846VA0", "E3846VB0", "E3846VC0",
               "E3846V00", "E3847VA0", "E3847VB0", "E3847VC0", "E3847V00",
               "E3936VA0", "E3936VB0", "E3939V00", "E3940V00", "E4683V00",
               "E7668V00", "E7673V00", "E4999V00", "E5000V00")

red.distr <- distr[distr$product %in% red.codes, ]

# Product codes for platelets
plat.codes <- c("budTR002", "trEnnApu", "A0004V00", "A0005V00", "A0006V00", "A0007V00", "A0008V00",
                "A0086VA0", "A0086VB0", "A0086V00", "A0088V00", "A0088VA0", "A0088VB0", "A0089V00",
                "A0089VB0", "A0089VA0", "A0090V00", "A0090VA0", "A0090VB0", "A0018V00", "A0020V00", 
                "A0021V00", "A0021VA0", "A0021VB0", "A0047V00", "A0049V00", "A0051V00", "A0054V00",
                "A0055V00", "A0056V00", "A0057V00", "A0059V00", "A0060V00", "A0067VA0", "A0067VB0",
                "A0067V00", "A0068VA0", "A0068VB0", "A0068V00", "A0075V00", "A0101V00", "A0102V00",
                "E3949V00", "E3953V00", "E3954V00", "E3955V00", "E3956V00", "E3957V00", "E3958V00",
                "E3959V00", "E3960V00", "E3961V00", "E3962V00", "E3963V00", "E3964V00", "E3965V00", 
                "E3966V00", "E3968VA0", "E3968VB0", "E3968V00", "E3970V00", "E3971V00", "E3973V00",
                "E3974V00", "E3976V00", "E3981V00", "E3995V00", "E3996V00", "E3997V00", "E3997VA0",
                "E3997VB0", "E4002V00", "E4004V00", "E6782V00", "E6783V00", "E6953V00", "E6860V00",
                "E6874VA0", "E6874V00", "E6874VB0", "E6875VB0", "E6875V00", "E7530V00", "E7530VA0",
                "E7530VB0", "E7531V00", "E7531VA0", "E7531VB0", "E6875VA0")

plat.distr <- distr[distr$product %in% plat.codes, ]
```

```{r create_datasets, include = FALSE}
# Create a full sequence of dates for imputation purposes
all.dates <- (seq.Date(min(red.distr$date),
                       max(red.distr$date),
                       "day"))
###           ###
#   RED CELLS   #
###           ###
all.red <- aggregate(red.distr$quantity, by = list(red.distr$date), sum); colnames(all.red) <- c("date", "pcs")
# Merge into a whole set with NAs
all.red <- merge(x = data.frame(date = all.dates),
                 y = all.red,
                 all.x = TRUE)
# Replace with zeroes
all.red[is.na(all.red)] <- 0
# Cut to time after 2014
all.red <- all.red[all.red$date >= as.Date("2014-01-06"), ]


# Extracting types
Ominus.distr <- extract_type(red.distr, "O -")  # This our custom function, see pffunctions.R
Oplus.distr <- extract_type(red.distr, "O +")
Aminus.distr <- extract_type(red.distr, "A -")
Aplus.distr <- extract_type(red.distr, "A +")
Bminus.distr <- extract_type(red.distr, "B -")
Bplus.distr <- extract_type(red.distr, "B +")
ABminus.distr <- extract_type(red.distr, "AB-")
ABplus.distr <- extract_type(red.distr, "AB+")


###           ###
#   PLATELETS   #
###           ###
all.plat <- aggregate(plat.distr$quantity, by = list(plat.distr$date), sum); colnames(all.plat) <- c("date", "pcs")
# Merge into a whole set with NAs
all.plat <- merge(x = data.frame(date = all.dates),
                  y = all.plat,
                  all.x = TRUE)
# Replace with zeroes
all.plat[is.na(all.plat)] <- 0
# Cut to time after 2014
all.plat <- all.plat[all.plat$date >= as.Date("2014-01-06"), ]
```

```{r datasets_monthly, include = FALSE, warning = FALSE}
# Aggregate all by months
red.monthly <- aggregate(pcs ~ month(date) + year(date), data = all.red, FUN = sum)
Ominus.monthly <- aggregate(pcs ~ month(date) + year(date), data = Ominus.distr, FUN = sum)
Oplus.monthly <- aggregate(pcs ~ month(date) + year(date), data = Oplus.distr, FUN = sum)
Aminus.monthly <- aggregate(pcs ~ month(date) + year(date), data = Aminus.distr, FUN = sum)
Aplus.monthly <- aggregate(pcs ~ month(date) + year(date), data = Aplus.distr, FUN = sum)
Bminus.monthly <- aggregate(pcs ~ month(date) + year(date), data = Bminus.distr, FUN = sum)
Bplus.monthly <- aggregate(pcs ~ month(date) + year(date), data = Bplus.distr, FUN = sum)
ABminus.monthly <- aggregate(pcs ~ month(date) + year(date), data = ABminus.distr, FUN = sum)
ABplus.monthly <- aggregate(pcs ~ month(date) + year(date), data = ABplus.distr, FUN = sum)
plat.monthly <- aggregate(pcs ~ month(date) + year(date), data = all.plat, FUN = sum)

# Dates
months <- seq(from = as.Date("2014-01-06"), to = max(distr$date), by = "month")

# Adjustment series
adj <- as.numeric(bizdays(ts(months, start = decimal_date(as.Date("2014-01-06")), frequency = 12), FinCenter = "Zurich"))
reverse_adj <- as.numeric(bizdays(ts(seq(6), start = decimal_date(as.Date(tail(months, 1))), frequency = 12), FinCenter = "Zurich"))

# Create a master frame
monthly <- data.frame(date = months,
                      red = red.monthly$pcs/adj,
                      Ominus = Ominus.monthly$pcs/adj,
                      Oplus = Oplus.monthly$pcs/adj,
                      Aminus = Aminus.monthly$pcs/adj,
                      Aplus = Aplus.monthly$pcs/adj,
                      Bminus = Bminus.monthly$pcs/adj,
                      Bplus = Bplus.monthly$pcs/adj,
                      ABminus = ABminus.monthly$pcs/adj,
                      ABplus = ABplus.monthly$pcs/adj,
                      plat = plat.monthly$pcs/adj)

monthly_real <- data.frame(date = months,
                           red = red.monthly$pcs,
                           Ominus = Ominus.monthly$pcs,
                           Oplus = Oplus.monthly$pcs,
                           Aminus = Aminus.monthly$pcs,
                           Aplus = Aplus.monthly$pcs,
                           Bminus = Bminus.monthly$pcs,
                           Bplus = Bplus.monthly$pcs,
                           ABminus = ABminus.monthly$pcs,
                           ABplus = ABplus.monthly$pcs,
                           plat = plat.monthly$pcs)
```

```{r datasets_weekly, include = FALSE}
# Weekly aggregation is a bit more tricky operation as weekly aggregate gives incorrect results, so we'll use
# a function of our own

red.weekly <- aggregate_weekly(all.red)
Ominus.weekly <- aggregate_weekly(Ominus.distr)
Oplus.weekly <- aggregate_weekly(Oplus.distr)
Aminus.weekly <- aggregate_weekly(Aminus.distr)
Aplus.weekly <- aggregate_weekly(Aplus.distr)
Bminus.weekly <- aggregate_weekly(Bminus.distr)
Bplus.weekly <- aggregate_weekly(Bplus.distr)
ABminus.weekly <- aggregate_weekly(ABminus.distr)
ABplus.weekly <- aggregate_weekly(ABplus.distr)
plat.weekly <- aggregate_weekly(all.plat)

# Create a master frame
weekly <- data.frame(week = red.weekly$week,
                     startdate = red.weekly$startdate,
                     red = red.weekly$pcs,
                     Ominus = Ominus.weekly$pcs,
                     Oplus = Oplus.weekly$pcs,
                     Aminus = Aminus.weekly$pcs,
                     Aplus = Aplus.weekly$pcs,
                     Bminus = Bminus.weekly$pcs,
                     Bplus = Bplus.weekly$pcs,
                     ABminus = ABminus.weekly$pcs,
                     ABplus = ABplus.weekly$pcs,
                     plat = plat.weekly$pcs)
```

# Old models
```{r}
# The old models took all of the unadjusted history and forecasted based on that. To get an accurate bench mark we'll need to erase
# 18 months from the end of the series, make one prediction, then extend and make a new prediciton, and so forth.
ets.forecasts <- c()
stl.forecasts <- c()
for(i in seq(18)){
 segment <- head(monthly_real$red, (length(monthly$red) - (19 - i)))
 beginning <- head(monthly$date, 1)
 series.ts <- ts(segment, start = decimal_date(beginning), frequency = 12)

 ets.forecast <- forecast(ets(series.ts), h = 1)$mean
 stl.forecast <- forecast(stl(series.ts, s.window = "periodic", t.window = 7), h = 1)$mean
 
 ets.forecasts <- c(ets.forecasts, ets.forecast)
 stl.forecasts <- c(stl.forecasts, stl.forecast)
}
validation <- head(tail(monthly_real$red, 19), 18)

ets.mape <- abs((validation - ets.forecasts)) / validation * 100
ets.cmape <- abs(ifelse(test = (validation - ets.forecasts) >= 0, 
                    yes = 2 * (validation - ets.forecasts), 
                    no =  (validation - ets.forecasts))) / validation * 100

stl.mape <- abs((validation - stl.forecasts)) / validation * 100
stl.cmape <- abs(ifelse(test = (validation - stl.forecasts) >= 0, 
                    yes = 2 * (validation - stl.forecasts), 
                    no =  (validation - stl.forecasts))) / validation * 100
```

# New models
```{r}
# The old models took all of the unadjusted history and forecasted based on that. To get an accurate bench mark we'll need to erase
# 18 months from the end of the series, make one prediction, then extend and make a new prediciton, and so forth.
ets.ad.forecasts <- c()
stl.ad.forecasts <- c()
for(i in seq(18)){
 segment <- head(monthly$red, (length(monthly_real$red) - (19 - i)))
 beginning <- head(monthly_real$date, 1)
 series.ts <- ts(segment, start = decimal_date(beginning), frequency = 12)

 ets.forecast <- forecast(ets(series.ts), h = 1)$mean
 stl.forecast <- forecast(stl(series.ts, s.window = "periodic", t.window = 7), h = 1)$mean
 
 ets.ad.forecasts <- c(ets.ad.forecasts, ets.forecast)
 stl.ad.forecasts <- c(stl.ad.forecasts, stl.forecast)
}
validation <- head(tail(monthly$red, 19), 18)

ets.ad.mape <- abs((validation - ets.ad.forecasts)) / validation * 100
ets.ad.cmape <- abs(ifelse(test = (validation - ets.ad.forecasts) >= 0, 
                    yes = 2 * (validation - ets.ad.forecasts), 
                    no =  (validation - ets.ad.forecasts))) / validation * 100

stl.ad.mape <- abs((validation - stl.ad.forecasts)) / validation * 100
stl.ad.cmape <- abs(ifelse(test = (validation - stl.ad.forecasts) >= 0, 
                    yes = 2 * (validation - stl.ad.forecasts), 
                    no =  (validation - stl.ad.forecasts))) / validation * 100
```


# Model selection without criticality
```{r monthly_model_selection_red, message = FALSE, warning = FALSE, echo = FALSE, results = FALSE}
# Define the series to be used
# We want to use 4 years of data. 3 years for the width of the rolling window and we'll let that run for a year.
segment <- head(tail(monthly$red, 49), 48) 
beginning <- head(tail(monthly$date, 49), 1)
series.ts <- ts(segment, start = decimal_date(beginning), frequency = 12)

# Standard
ets.capes <- find_errors(segment, beginning, series.ts, "ets", smooth = "none", freq = "monthly", critical = FALSE)
stl.capes <- find_errors(segment, beginning, series.ts, "stl", smooth = "none", freq = "monthly", critical = FALSE)
tbats.capes <- find_errors(segment, beginning, series.ts, "tbats", smooth = "none", freq = "monthly", critical = FALSE)
stlf.capes <- find_errors(segment, beginning, series.ts, "stlf", smooth = "none", freq = "monthly", critical = FALSE)
lmx2.capes <- find_errors(segment, beginning, series.ts, "tslm", smooth = "none", freq = "monthly", critical = FALSE)
naive.capes <- find_errors(segment, beginning, series.ts, "naive", smooth = "none", freq = "monthly", critical = FALSE)
snaive.capes <- find_errors(segment, beginning, series.ts, "snaive", smooth = "none", freq = "monthly", critical = FALSE)
rwf.capes <- find_errors(segment, beginning, series.ts, "rwf", smooth = "none", freq = "monthly", critical = FALSE)
meanf.capes <- find_errors(segment, beginning, series.ts, "meanf", smooth = "none", freq = "monthly", critical = FALSE)
# Smooth .25
smthets.capes <- find_errors(segment, beginning, series.ts, "ets", smooth = ".25", freq = "monthly", critical = FALSE)
smthstl.capes <- find_errors(segment, beginning, series.ts, "stl", smooth = ".25", freq = "monthly", critical = FALSE)
smthtbats.capes <- find_errors(segment, beginning, series.ts, "tbats", smooth = ".25", freq = "monthly", critical = FALSE)
smthstlf.capes <- find_errors(segment, beginning, series.ts, "stlf", smooth = ".25", freq = "monthly", critical = FALSE)
smthlmx2.capes <- find_errors(segment, beginning, series.ts, "tslm", smooth = ".25", freq = "monthly", critical = FALSE)
smthnaive.capes <- find_errors(segment, beginning, series.ts, "naive", smooth = ".25", freq = "monthly", critical = FALSE)
smthsnaive.capes <- find_errors(segment, beginning, series.ts, "snaive", smooth = ".25", freq = "monthly", critical = FALSE)
smthrwf.capes <- find_errors(segment, beginning, series.ts, "rwf", smooth = ".25", freq = "monthly", critical = FALSE)
smthmeanf.capes <- find_errors(segment, beginning, series.ts, "meanf", smooth = ".25", freq = "monthly", critical = FALSE)
# Smooth .10
smth10ets.capes <- find_errors(segment, beginning, series.ts, "ets", smooth = ".10", freq = "monthly", critical = FALSE)
smth10stl.capes <- find_errors(segment, beginning, series.ts, "stl", smooth = ".10", freq = "monthly", critical = FALSE)
smth10tbats.capes <- find_errors(segment, beginning, series.ts, "tbats", smooth = ".10", freq = "monthly", critical = FALSE)
smth10stlf.capes <- find_errors(segment, beginning, series.ts, "stlf", smooth = ".10", freq = "monthly", critical = FALSE)
smth10lmx2.capes <- find_errors(segment, beginning, series.ts, "tslm", smooth = ".10", freq = "monthly", critical = FALSE)
smth10naive.capes <- find_errors(segment, beginning, series.ts, "naive", smooth = ".10", freq = "monthly", critical = FALSE)
smth10snaive.capes <- find_errors(segment, beginning, series.ts, "snaive", smooth = ".10", freq = "monthly", critical = FALSE)
smth10rwf.capes <- find_errors(segment, beginning, series.ts, "rwf", smooth = ".10", freq = "monthly", critical = FALSE)
smth10meanf.capes <- find_errors(segment, beginning, series.ts, "meanf", smooth = ".10", freq = "monthly", critical = FALSE)

m <- matrix(c(ets.capes, stl.capes, tbats.capes, stlf.capes, lmx2.capes, 
              naive.capes, snaive.capes, rwf.capes, meanf.capes,
              smthets.capes, smthstl.capes, smthtbats.capes, smthstlf.capes, 
              smthlmx2.capes, smthnaive.capes, smthsnaive.capes, smthrwf.capes, smthmeanf.capes,
              smth10ets.capes, smth10stl.capes, smth10tbats.capes, smth10stlf.capes, 
              smth10lmx2.capes, smth10naive.capes, smth10snaive.capes, smth10rwf.capes, smth10meanf.capes),
            ncol = 27,
            byrow = FALSE)

modelnames <- c("ETS", "STL", "TBATS", "STLF", "LMx2", "NAIVE", "SNAIVE", "RWF", "MEANF",
                "ETS.25", "STL.25", "TBATS.25", "STLF.25", "LMx2.25", "NAIVE.25", "SNAIVE.25", "RWF.25", "MEANF.25",
                "ETS.10", "STL.10", "TBATS.10", "STLF.10", "LMx2.10", "NAIVE.10", "SNAIVE.10", "RWF.10", "MEANF.10")
colnames(m) <- modelnames

mdf <- as.data.frame(m)

chosen.model <- which.min(colMeans(mdf))[[1]]

# Actual forecasts if this model chosen
fdf <- chosen_forecast(chosen.model, series.ts, reverse_adj, freq = "monthly")

# Prepare to save the new forecast into file
save.this <- data.frame(time = tail(monthly$date, 1), 
                        model = modelnames[chosen.model], 
                        forecast = fdf$fcast[1],
                        upper80 = fdf$upper80[1],
                        upper95 = fdf$upper95[1],
                        lower80 = fdf$lower80[1],
                        lower95 = fdf$lower95[1])

#Save only if file already exists (some histories have not been initialized yet)
if(file.exists("histories/monthly_non_crit_red.csv")){
  # Do not save if forecast already exists in history
  existing.history <- read.csv("histories/monthly_non_crit_red.csv")
  existing.history$time <- as.Date(existing.history$time)
  if(save.this$time %in% existing.history$time){
    warning("Data point already in file!")
  } else{
      # Save to file for historical review
      write.table(save.this, file = "histories/monthly_red.csv", sep = ",", append = TRUE, row.names = FALSE, col.names = FALSE)
    }
} else{
    warning("History not initialized!")
  }

```

```{r red_history, fig.align = "center", echo = FALSE}
# Load history if it exists
if(file.exists("histories/monthly_red.csv")){
  FILE.EXISTS <- TRUE
  history <- head(read.csv("histories/monthly_red.csv", header = TRUE), -1)
  history$err <- abs((tail(head(monthly_real$red, -1), length(history$forecast)) - history$forecast) / tail(head(monthly_real$red, -1),
                                                                                                            length(history$forecast)))*100
  
  cmape <- abs(ifelse(test = (tail(head(monthly_real$red, -1), length(history$forecast)) - history$forecast) >= 0, 
                    yes = 2 * (tail(head(monthly_real$red, -1), length(history$forecast)) - history$forecast),
                    no = (tail(head(monthly_real$red, -1), length(history$forecast)) - history$forecast))/tail(head(monthly_real$red, -1),
                                                                                                            length(history$forecast)))*100

  ggplot(data = history, aes(x = as.Date(time), y = forecast, colour = "Forecast"), label = model) +
    geom_line(aes(colour = "Forecast"), size = 0.9, alpha = 1) +
    geom_line(data = head(monthly_real, -1), aes(x = date, y = red, colour = "Data"), size = 0.8, alpha = 0.7) +
    labs(title = "Red cell forecast history",
         subtitle = paste0("Mean error: ", round(mean(history$err), 2), "%"),
         x = "",
         y = "Units per month",
         colour = "Series: ") +
    theme_minimal() + theme(legend.position = "bottom", legend.margin = margin(t = -20, b = 0)) + scale_colour_manual(values = c("#D55E00", "#0072B2"))
} else {
  FILE.EXISTS <- FALSE
  warning("History not available.")

}
```
